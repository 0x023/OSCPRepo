<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>DLL Replacement/Creation</title>
</head><body><b>What are we exploiting? </b>read more <a href="http://www.greyhathacker.net/?p=738"><b>article</b></a><b>&nbsp;</b><br/>
The goal here is to get local admin rights on the machine. In order to achieve this we need three things to make this work<br/>
&nbsp; Windows DLL search order<br/>
&nbsp; DLL hijacking vulnerability<br/>
&nbsp; Weak folder permissions<br/>
<br/>
This example is a special case of DLL hijacking. Programs usually can't function by themselves, they have a lot of resources they need to hook into (mostly DLL's but also proprietary files). If a program or service loads a file from a directory we have write access to we can abuse that to pop a shell with the privileges the program runs as.<br/>
<br/>
Generally a Windows application will use pre-defined search paths to find DLL's and it will check these paths in a specific order. DLL hijacking usually happens by placing a malicious DLL in one of these paths while making sure that DLL is found before the legitimate one. This problem can be mitigated by having the application specify absolute paths to the DLL's that it needs.<br/>
<br/>
You can see the DLL search order on 32-bit systems below:<br/>
1 - The directory from which the application loaded<br/>
2 - 32-bit System directory (C:\Windows\System32)<br/>
3 - 16-bit System directory (C:\Windows\System)<br/>
4 - Windows directory (C:\Windows)<br/>
5 - The current working directory (CWD)<br/>
6 - Directories in the PATH environment variable (system then user)<br/>
<br/>
<b>It sometimes happens that applications attempt load DLL's that do not exist on the machine</b>. This may occur due to several reasons, for example if the DLL is only required for certain plug-ins or features which are not installed. In this case Parvez discovered that certain Windows services attempt to load DLL's that do not exist in default installations.<br/>
<br/>
Since the DLL in question does not exist we will end up traversing all the search paths. As a low privilege user we have little hope of putting a malicious DLL in 1-4, 5 is not a possibility in this case because we are talking about a Windows service but if we have write access to any of the directories in the Windows PATH we win.<br/>
<br/>
Let's have a look at how this works in practise, for our example we will be using the IKEEXT (IKE and AuthIP IPsec Keying Modules) service which tries to load <b>wlbsctrl.dll</b>.<br/>
<img src="image.png" /><br/>
<br/>
Now we know the necessary conditions are met we can generate a malicious DLL and pop a shell! (Need to use msfvenom here instead, but gen a payload and output in DLL format).<br/>
<img src="image 2.png" /><br/>
<br/>
After transferring the DLL to our target machine all we need to do is rename it to wlbsctrl.dll and move it to "C:\Python27". Once this is done we need to wait patiently for the machine to be rebooted (or we can try to force a reboot) and we will get a SYSTEM shell.<br/>
<br/>
<br/>
</body></html>