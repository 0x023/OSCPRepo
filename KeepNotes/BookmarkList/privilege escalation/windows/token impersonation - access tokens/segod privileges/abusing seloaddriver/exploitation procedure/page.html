<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Exploitation Procedure</title>
</head><body>0x03 – Exploitation procedure<br/>
<br/>
<b>Obtaining a shell with an unrestricted access token</b><br/>
In order to obtain an unrestricted access token we have the following options:<br/>
<br/>
Make use of the “Run as administrator” functionality to elevate any process initiated by the user. The use of these mechanisms in the context of users who are not administrators will allow obtaining a token without restrictions.<ul><li>Make use of the <a href="https://code.kliu.org/misc/elevate/">elevate</a> tool. This tool allows to start an elevated process.</li>
</ul>
<div style="text-align: justify">elevate.exe -c cmd.exe</div><ul><li>Compile an application including a manifest to indicate the use of an unrestricted token, which will trigger the UAC prompt when started.</li>
<li>Use some technique to bypass UAC.</li>
</ul>
&nbsp;<br/>
<b>SeLoadDriverPrivilege privilege activation</b><br/>
Once we have an unrestricted token we can notice that, by default the SeLoadDriverPrivilege is available in the user’s privilege list on the access token but disabled by default. To make use of the privilege it is necessary to activate it explicitly. In order to accomplish this we have to perform the following steps. First we’ll need to acquire a reference of the privilege by using LookupPrivilegeValue() API. After that, the function AdjustTokenPriviliges() can be used to activate the privilege.<br/>
<br/>
<br/>
<b>Driver Load</b><br/>
Loading drivers from user space can be done using the Windows NTLoadDriver API, its format is detailed below:<br/>
<br/>
NTSTATUS NTLoadDriver(<br/>
&nbsp; _In_ PUNICODE_STRING DriverServiceName<br/>
);<br/>
<br/>
This function takes as the only input parameter DriverServiceName, a pointer to a string in UNICODE format which specifies the registry key that defines the driver configuration:<br/>
<br/>
\Registry\Machine\System\CurrentControlSet\Services\DriverName<br/>
<br/>
Under the DriverName key there are different configuration parameters that can be defined. The most relevant are:<br/>
<ul><li><b>ImagePath: </b>REG_EXPAND_SZ type value which specifies the driver path. In this context, the path should be a directory with modification permissions by the non-privileged user.</li>
<li><b>Type</b>: Value of type REG_WORD in which the type of the service is indicated. For our purpose, the value should be defined as SERVICE_KERNEL_DRIVER (0x00000001).</li>
</ul>
&nbsp;<br/>
One thing to keep in mind is that the registry key passed to NTLoadDriver is by default located under the HKLM key (HKEY_LOCAL_MACHINE), which defines modification permissions only to the Administrators group. Although the documentation indicates the use of the key ” Registry Machine System CurrentControlSet Services “, the NTLoadDriver API does not restrict paths under the HKCU (HKEY_CURRENT_USER) key, which can be modified by non-privileged users.<br/>
<br/>
Taking into account this situation, when invoking the NTLoadDriver API, it will be possible to use a registry key under HKCU (HKEY_CURRENT_USER), specifying a path following this format:<br/>
<br/>
RegistryUser{NON_PRIVILEGED_USER_SID}<br/>
<br/>
The account’s SID value can be obtained programmatically by using the GetTokenInformation API, which allows the user to obtain his access token information. Alternatively, the SID can be consulted using the “whoami /all” command, or through the following PowerShell instructions:<br/>
<br/>
(New-Object System.Security.Principal.NTAccount("NOMBRE_CUENTA_USUARIO")).Translate([System.Security.Principal.SecurityIdentifier]).value<br/>
# En el contexto de un usuario del dominio.<br/>
Get-ADUser -Identity ' NOMBRE_CUENTA_USUARIO ' | select SID<br/>
<br/>
<br/>
</body></html>