<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Bypass</title>
</head><body><b>Bypassing the added .php and other extra file-endings</b><br/>
It is common to add the file-extension through the php-code.<br/>
<br/>
The php is added to the filename, this will mean that we will not be able to find the files we are looking for. Since the file /etc/passwd.php does not exist. However, if we add the nullbyte to the end of our attack-string the .php will not be taken into account. So we add %00 to the end of our attack-string.<br/>
http://example.com/page=../../../../../../etc/passwd%00<br/>
The technique only works in versions below php 5.3<br/>
<br/>
Another way to deal with this problem is just to add a question mark to your attack-string. This way the stuff after gets interpreted as a parameter and therefore excluded. Here is an example:<br/>
http://example.com/page=../../../../../../etc/passwd?<br/>
<br/>
<br/>
<br/>
<b>Bypassing php-execution</b><br/>
So if you have an LFI you can easily read .txt-files but not .php files. That is because they get executed by the webserver, since their file-ending says that it contains code. This can be bypassed by using a build-in php-filter.<br/>
http://example.com/index.php?page=php://filter/convert.base64-encode/resource=index<br/>
<br/>
Here you use a php-filter to convert it all into base64. So in return you get the whole page base64 encoded. Now you only need to decode it. Save the base64-text into a file and then run:<br/>
base64 -d savefile.php</body></html>