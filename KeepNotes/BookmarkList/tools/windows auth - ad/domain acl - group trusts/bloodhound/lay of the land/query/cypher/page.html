<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Cypher</title>
</head><body>Cypher<br/>
BloodHound uses Neo4j as its graph database. Neo4j interactions are driven by “Cypher”. Cypher was inspired by SQL and was developed as a declarative graph query language for describing patterns in graphs visually. BloodHound comes pre-built with several “Cypher” queries; however, you can create your own to meet your specific needs.<br/>
<br/>
The built-in queries are good enough for a penetration tester to achieve success on most engagements without the need to develop additional custom Cypher queries. This, and the requirement to learn Cypher, result in custom queries being frequently ignored. However, learning even just a bit of Cypher can prove to be well worth the effort, as custom queries are a powerful feature of BloodHound.<br/>
<br/>
Common terms from Graph theory are directly applicable to the Neo4j Graph Database, such as edges and nodes. In the context of BloodHound, a node represents either a User, Group, Computer, or Domain. Each node represents an object that can be acted upon when moving through an Active Directory Environment.<br/>
<br/>
Edges represents relationships between nodes. In the context of BloodHound, edges represent MemberOf, AdminTo, HasSession, TrustedBy. In version 1.3 of BloodHound, a new set of edges for access control entries was introduced. These include ForceChangePassword, AddMemebers, GenericAll, GenericWrite, WriteOwner, WrieDACL, and AllExtendedRights. Together edges and nodes create the paths that we use in BloodHound.<br/>
<br/>
Check Out CptJesus’s <a href="https://blog.cptjesus.com/posts/introtocypher">blog on cypher</a>&nbsp;for a more advanced look!</body></html>