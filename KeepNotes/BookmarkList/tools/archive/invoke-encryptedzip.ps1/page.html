<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Invoke-EncryptedZip.ps1</title>
</head><body>&lt;#<br/>
<br/>
&nbsp; &nbsp; Invoke-MakeEncZip via .NET<br/>
&nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
#&gt;<br/>
<br/>
<br/>
function Invoke-EncryptedZip {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip is a utility to make a Enrypted Zip compresed file from a provided folder.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; This allows users to stage files in designated folder for exfil, or protection from final storage location. <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://technet.microsoft.com/en-us/library/2009.04.heyscriptingguy.aspx<br/>
<br/>
&nbsp; &nbsp; .PARAMETER SourceDirectory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required source directory to be Zip Encrypted archived<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file name to be outputed<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file output directory<br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required final encrypted file name <br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required final encrypted file path<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipMethod<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Select the Method (COM, NET) to be used to Zip file (DEFAULT: NET)<br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptMethod<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Select the Method (Stream, Memory) to be used to to encrypt the (DEFAULT: Stream)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Memory is only good to about 1MB max to prevent PS consuming to much mem.<br/>
<br/>
&nbsp; &nbsp; .PARAMETER CleanUp<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Switch to enable clean up of source folder and zip file created. (DEFAULT: False)<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip -SourceDirectory "C:\CINEBENCHR15.038" -ZipFileName "test.zip" -ZipFilePath "C:\" -EncryptedFilePath "C:\"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip -SourceDirectory "C:\CINEBENCHR15.038" -ZipFileName "test.zip" -ZipFilePath "C:\\" -EncryptedFilePath "C:\" -ZipMethod &nbsp;'COM' <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip -SourceDirectory "C:\CINEBENCHR15.038" -ZipFileName "test.zip" -ZipFilePath "C:\\" -EncryptedFilePath "C:\" -ZipMethod &nbsp;'COM' -EncryptMethod 'Memory'<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip -SourceDirectory "C:\CINEBENCHR15.038" -ZipFileName "test.zip" -ZipFilePath "C:\\" -EncryptedFilePath "C:\" -ZipMethod &nbsp;'NET' -EncryptMethod 'Stream' -ZipMethod 'NET' -EncryptMethod 'Stream' -CleanUp -Verbose<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SourceDirectory,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 2)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFilePath,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 3)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 4)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFilePath,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 5)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateSet("COM", "NET")]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipMethod = "NET",<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 6)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateSet("Stream", "Memory")]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptMethod = "Stream",<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 7)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $CleanUp = $false<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if(![IO.Directory]::Exists($SourceDirectory)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] Cant find source directory $SourceDirectory, baling out"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Create zip file and test to make sure it was wrote to correct location<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($ZipMethod -eq "COM") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create-ZipFileCOM -SourceDirectory $SourceDirectory -ZipFileName $ZipFileName -ZipFilePath $ZipFilePath<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($ZipMethod -eq "NET") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create-ZipFileNET -SourceDirectory $SourceDirectory -ZipFileName $ZipFileName -ZipFilePath $ZipFilePath<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } <br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFile = "$ZipFilePath$ZipFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if(-not (test-path($ZipFile))) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Output "[!] No zip present after creation, baling out!"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; sleep 2<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; #Begin main process block exec of encryption <br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($EncryptMethod -eq "Stream") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Stream encryption selected"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $AesKey = Create-AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Encrypt-AESFileStream -SourceDirectory $ZipFilePath -SourceFile $ZipFileName -EncryptedFileName $EncryptedFileName -EncryptedFilePath $EncryptedFilePath -AesKey $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove-variable AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [GC]::Collect()<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($EncryptMethod -eq "Memory") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Memory encryption selected"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileBytes = [System.IO.File]::ReadAllBytes($ZipFile)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $AesKey = Create-AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $EncryptedBytes = Encrypt-Bytes -AesKey $AesKey -Bytes $FileBytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove-variable FileBytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [GC]::Collect()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFile = "$EncryptedFilePath$EncryptedFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [io.file]::WriteAllBytes($EncryptedFile, $EncryptedBytes)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove-variable EncryptedBytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [GC]::Collect()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = New-Object –TypeName PSObject<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Computer –Value $env:COMPUTERNAME<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Key –Value $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Files –Value $EncryptedFile<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [GC]::Collect()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($CleanUp) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # start file clean up routine <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-Item $SourceDirectory -Recurse -Force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Source folder deleted: $SourceDirectory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-Item $ZipFile -Force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Zip archive deleted: $ZipFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if([IO.Directory]::Exists($SourceDirectory)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "[!] WARNING: Source folder deletion failed, please manualy remove: $SourceDirectory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if([System.IO.File]::Exists($ZipFileName)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "[!] WARNING: Zip deletion failed, please manualy remove: $ZipFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
<br/>
function Invoke-DecryptZip {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-EncryptedZip<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-DecryptZip is a utility to decrypt files created with this utility.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://technet.microsoft.com/en-us/library/2009.04.heyscriptingguy.aspx<br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required final encrypted file name <br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required final encrypted file path<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipMethod<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Select the Method (COM, NET) to be used to Zip file (DEFAULT: NET)<br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptMethod<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Select the Method (Stream, Memory) to be used to to encrypt the (DEFAULT: Stream)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Memory is only good to about 1MB max to prevent PS consuming to much mem.<br/>
<br/>
&nbsp; &nbsp; .PARAMETER CleanUp<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Switch to enable clean up of source folder and zip file created. (DEFAULT: False)<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-DecryptZip -EncryptedFileName 'shellcode.dat' -EncryptedFilePath 'C:\Users\admin\Desktop\' -AesKey &nbsp;'H2dbIaoK2MFYU2ge/4cx00XjLuLSC63odhqhKP4vC84=' <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Invoke-DecryptZip -EncryptedFileName 'shellcode.dat' -EncryptedFilePath 'C:\Users\admin\Desktop\' -AesKey &nbsp;'H2dbIaoK2MFYU2ge/4cx00XjLuLSC63odhqhKP4vC84=' -CleanUp -Verbose<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Computer &nbsp; &nbsp; Key &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Files<br/>
&nbsp; &nbsp; &nbsp; &nbsp; -------- &nbsp; &nbsp; --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-----<br/>
&nbsp; &nbsp; &nbsp; &nbsp; TEST &nbsp; &nbsp; &nbsp; &nbsp; H2dbIaoK2MFYU2ge/4cx00XjLuLSC63odhqhKP4vC84= C:\Users\admin\Desktop\shellcode.zip<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesKey,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 2)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 3)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFilePath,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 4)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateSet("COM", "NET")]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipMethod = "NET",<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 5)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateSet("Stream", "Memory")]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptMethod = "Stream",<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 6)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $CleanUp = $false<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFile = "$EncryptedFilePath$EncryptedFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $DecryptedFile = $EncryptedFileName.Split(".")[0] + ".zip"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if(![System.IO.File]::Exists($EncryptedFile)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] Cant find Encrypted File $EncryptedFile, baling out"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($EncryptMethod -eq "Stream") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Stream dcryption selected"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Decrypt-AESFileStream -DestionationDirectory $EncryptedFilePath -DestionationFile $DecryptedFile -EncryptedFileName $EncryptedFileName -EncryptedFilePath $EncryptedFilePath -AesKey $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove-variable AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [GC]::Collect()<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; #Begin main process block exec of de ziping <br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFile = "$EncryptedFilePath$DecryptedFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $DecryptedFolder = $EncryptedFileName.Split(".")[0]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $DecompressedZipFolder = "$EncryptedFilePath$DecryptedFolder"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($ZipMethod -eq "NET") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create-DecompressedZipFileNET -ZipFilePath $ZipFile -OutputFolderPath $DecompressedZipFolder<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Zip decompressed to: $DecompressedZipFolder"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if(![IO.Directory]::Exists($DecompressedZipFolder)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] No folder Decompressed present after creation, baling out!"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [GC]::Collect()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($CleanUp) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # start file clean up routine <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-Item $EncryptedFile -Force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Source file deleted: $EncryptedFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-Item $ZipFile -Force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Zip archive deleted: $ZipFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if([IO.Directory]::Exists($EncryptedFile)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "[!] WARNING: Source folder deletion failed, please manualy remove: $EncryptedFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if([System.IO.File]::Exists($ZipFile)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "[!] WARNING: Zip deletion failed, please manualy remove: $ZipFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
function Create-AesManagedObject {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Makes the required AES object for encryption and decryption <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://gist.github.com/ctigeek/2a56648b923d198a6e60<br/>
<br/>
&nbsp; &nbsp; .PARAMETER AesKey<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; The required AES key being used for encryption (base64 key)<br/>
<br/>
&nbsp; &nbsp; .PARAMETER AesIV<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; The required AES IV being used for encryption (base64 iv)<br/>
<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Create-AesManagedObject $key $iv<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesKey,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesIV<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($AesKey) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Key being used for encryption: $AesKey"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($AesIV) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] IV being used for encryption: $iv"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp;<br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #Begin main process block<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged = New-Object "System.Security.Cryptography.AesManaged"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.Mode = [System.Security.Cryptography.CipherMode]::CBC<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.Padding = [System.Security.Cryptography.PaddingMode]::Zeros<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.BlockSize = 128<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.KeySize = 256<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($AesIV) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($AesIV.getType().Name -eq "String") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.IV = [System.Convert]::FromBase64String($AesIV)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.IV = $AesIV<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($AesKey) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($AesKey.getType().Name -eq "String") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.Key = [System.Convert]::FromBase64String($AesKey)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.Key = $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed AES object creation"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # return obj to pipeline<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $aesManaged<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
function Create-AesKey {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Makes the required AES key object to pass<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://gist.github.com/ctigeek/2a56648b923d198a6e60<br/>
<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $b64key = Create-AesKey <br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] AES key creation started"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #Begin main process block<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged = Create-AesManagedObject<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.GenerateKey()<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed AES key creation"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # return obj to pipeline<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesKey = [System.Convert]::ToBase64String($aesManaged.Key)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] AES key created: $AesKey"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return $AesKey<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
}<br/>
<br/>
<br/>
function Encrypt-Bytes {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Makes the required AES object for encryption and decryption <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://gist.github.com/ctigeek/2a56648b923d198a6e60<br/>
<br/>
&nbsp; &nbsp; .PARAMETER AesKey<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; The required AES key being used for encryption (base64 key)<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Bytes<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; The bytes to be encrypted via AES<br/>
<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Encrypt-Bytes $AesKey $FileBytes<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesKey,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Bytes<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Key being used for encryption of bytes: $key"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $aesManaged = Create-AesManagedObject $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $encryptor = $aesManaged.CreateEncryptor()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $encryptedData = $encryptor.TransformFinalBlock($Bytes, 0, $Bytes.Length);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [byte[]] $fullData = $aesManaged.IV + $encryptedData<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $aesManaged.Dispose()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # $finalbytes = [System.Convert]::ToBase64String($fullData)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $finalbytes = $fullData<br/>
<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed AES encryption of bytes"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # return obj to pipeline<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $finalbytes<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
function Create-ZipFileCOM {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Makes the required AES object for encryption and decryption <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://serverfault.com/questions/456095/zipping-only-files-using-powershell<br/>
<br/>
&nbsp; &nbsp; .PARAMETER SourceDirectory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required source directory to be Zip archived<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file name to be outputed<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file output directory<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Create-ZipFile -SourceDirectory "C:\Users\KILLSWITCH-GUI\Desktop\Ethereum-Wallet-win32-0-8-10\win-ia32-unpacked" -ZipFileName "test.zip" -ZipFilePath "C:\Users\KILLSWITCH-GUI\Desktop\" -Verbose<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SourceDirectory,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFilePath<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $zipFile = "$ZipFilePath$ZipFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Full Zip file output path: $zipFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Full path of folder to be zipped: $SourceDirectory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; #Prepare zip file on disk<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if(-not (test-path($zipFile))) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set-content $zipFile ("PK" + [char]5 + [char]6 + ("$([char]0)" * 18))<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dir $zipFile).IsReadOnly = $false &nbsp;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $shellApplication = new-object -com shell.application<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $zipPackage = $shellApplication.NameSpace($zipFile)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $files = Get-ChildItem -Path $SourceDirectory <br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; foreach($file in $files) { <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $zipPackage.CopyHere($file.FullName)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while($zipPackage.Items().Item($file.name) -eq $null){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed compression on file: $file"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Start-sleep -seconds 1<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $len = (Get-Item "$zipFile").length<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # TODO: Fix addtype<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # $size = Convert-Size -Size $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $size = $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed Zip file creation"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Final Zip file size: $size"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
<br/>
function Create-DecompressedZipFileNET {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Uses .NET to Decompressed zip file to directory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://stackoverflow.com/questions/1153126/how-to-create-a-zip-archive-with-powershell<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file full file path Ex: C:\Windows\Tasks\test.zip<br/>
<br/>
&nbsp; &nbsp; .PARAMETER OutputFolderPath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required output directory that will be created Ex: C:\Windows\Tasks\test<br/>
&nbsp; &nbsp; &nbsp; &nbsp; This creates a directory. As .NET can only zip a directory.<br/>
&nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFilePath,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $OutputFolderPath<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Full path of file to be Decompressed: $ZipFilePath"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Full path of zip file to be stored to: $OutputFolderPath"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Reflection.Assembly]::LoadWithPartialName("System.IO.Compression.FileSystem") &gt; $null<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [System.IO.Compression.ZipFile]::ExtractToDirectory($ZipFilePath,$OutputFolderPath)<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed Decompressed file creation"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
function Create-ZipFileNET {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Uses .NET to zip file directory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://stackoverflow.com/questions/1153126/how-to-create-a-zip-archive-with-powershell<br/>
<br/>
&nbsp; &nbsp; .PARAMETER SourceDirectory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required source directory to be Zip archived<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file name to be outputed<br/>
<br/>
&nbsp; &nbsp; .PARAMETER ZipFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Zip file output directory<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Create-ZipFile -SourceDirectory "C:\Users\KILLSWITCH-GUI\Desktop\Ethereum-Wallet-win32-0-8-10\win-ia32-unpacked" -ZipFileName "test.zip" -ZipFilePath "C:\Users\KILLSWITCH-GUI\Desktop\" -Verbose<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SourceDirectory,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ZipFilePath<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $zipFile = "$ZipFilePath$ZipFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Full Zip file output path: $zipFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Full path of folder to be zipped: $SourceDirectory"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Reflection.Assembly]::LoadWithPartialName("System.IO.Compression.FileSystem") &gt; $null<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $compressionLevel = [System.IO.Compression.CompressionLevel]::Optimal<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [System.IO.Compression.ZipFile]::CreateFromDirectory($SourceDirectory,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $zipFile, $compressionLevel, $false)<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $len = (Get-Item "$zipFile").length<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # TODO: Fix addtype<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # $size = Convert-Size -Size $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $size = $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Completed Zip file creation"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Final Zip file size: $size"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
function Encrypt-AESFileStream {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Uses .NET to encrypt using file stream rather than fully in mem.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://stackoverflow.com/questions/1153126/how-to-create-a-zip-archive-with-powershell<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptostream.cryptostream(v=vs.110).aspx<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://gallery.technet.microsoft.com/scriptcenter/EncryptDecrypt-files-use-65e7ae5d<br/>
<br/>
<br/>
&nbsp; &nbsp; .PARAMETER SourceDirectory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required source directory of file directory to be encrypted<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; .PARAMETER SourceFile<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required source file name to be encrypted<br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required final encrypted file name <br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required final encrypted file path<br/>
<br/>
&nbsp; &nbsp; .PARAMETER AesKey<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required AES key to be used for encryption<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; .NOTES<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Adapted from Tyler Siegrist.<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $key = Create-AesKey<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Encrypt-AESFileStream -SourceDirectory "C:\Users\admin\Desktop\" -SourceFile "secrets.txt" -EncryptedFileName "secrets.crypto" -EncryptedFilePath "C:\Users\admin\Desktop\" -AesKey $key<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Computer &nbsp; &nbsp; Key &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Files<br/>
&nbsp; &nbsp; &nbsp; &nbsp; -------- &nbsp; &nbsp; --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-----<br/>
&nbsp; &nbsp; &nbsp; &nbsp; TEST &nbsp; &nbsp; &nbsp; &nbsp; 7f/3e9cQF8yx2UNhG/Dc6XYLKYqXptK1ALB+tP3QUwA= C:\Users\admin\Desktop\secrets.crypto<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SourceDirectory,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SourceFile,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 2)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 3)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFilePath,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 4)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesKey<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFile = "$EncryptedFilePath$EncryptedFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SourceFileName = "$SourceDirectory$SourceFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AESProvider = Create-AesManagedObject -AesKey $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [System.Reflection.Assembly]::LoadWithPartialName('System.Security.Cryptography')<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if(![System.IO.File]::Exists($SourceFileName)){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] File check failed: $SourceFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] File not present? Check your self!"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] File check passed: $SourceFileName"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # create the file stream for the encryptor<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader = New-Object System.IO.FileStream($SourceFileName, [System.IO.FileMode]::Open)<br/>
&nbsp; &nbsp; &nbsp; &nbsp;<br/>
&nbsp; &nbsp;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # create destination file<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Try<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter = New-Object System.IO.FileStream($EncryptedFile, [System.IO.FileMode]::Create)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Catch<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] Unable to open file to write: $FileStreamWriter"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # write IV length &amp; IV to encrypted file header<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AESProvider.GenerateIV()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Write([System.BitConverter]::GetBytes($AESProvider.IV.Length), 0, 4)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Write($AESProvider.IV, 0, $AESProvider.IV.Length)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # start encryption routine <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Encrypting $SourceFileName with an IV of $([System.Convert]::ToBase64String($AESProvider.IV))"<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; try<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Transform = $AESProvider.CreateEncryptor()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream = New-Object System.Security.Cryptography.CryptoStream($FileStreamWriter, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Int]$Count = 0<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Int]$BlockSizeBytes = $AESProvider.BlockSize / 8<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Byte[]]$Data = New-Object Byte[] $BlockSizeBytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Do<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Count = $FileStreamReader.Read($Data, 0, $BlockSizeBytes)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.Write($Data, 0, $Count)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; While($Count -gt 0)<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #Close open files<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.FlushFinalBlock()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # finshed<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Successfully encrypted file: $EncryptedFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; catch<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] Failed to encrypt: $SourceFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-Item $EncryptedFile -Force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $len = (Get-Item "$EncryptedFile").length<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # TODO: Fix addtype<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # $size = Convert-Size -Size $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $size = $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Final encrypted file size: $size"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result = New-Object –TypeName PSObject<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Computer –Value $env:COMPUTERNAME<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Key –Value $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Files –Value $EncryptedFile<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
function Decrypt-AESFileStream {<br/>
&lt;#<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Author: Alexander Rymdeko-Harvey (@Killswitch-GUI)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; License: BSD 3-Clause<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Dependencies: None<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Optional Dependencies: None<br/>
<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Uses .NET to decrypt using file stream rather than fully in mem.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Refrence: https://stackoverflow.com/questions/1153126/how-to-create-a-zip-archive-with-powershell<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://msdn.microsoft.com/en-us/library/system.security.cryptography.cryptostream.cryptostream(v=vs.110).aspx<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://gallery.technet.microsoft.com/scriptcenter/EncryptDecrypt-files-use-65e7ae5d<br/>
<br/>
<br/>
&nbsp; &nbsp; .PARAMETER DestionationDirectory<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Destionation directory of file to be placed on disk<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; .PARAMETER DestionationFile<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required Destionation file name to be placed on disk<br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFileName<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required encrypted file name <br/>
<br/>
&nbsp; &nbsp; .PARAMETER EncryptedFilePath<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required encrypted file path<br/>
<br/>
&nbsp; &nbsp; .PARAMETER AesKey<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Required AES key to be used for decryption<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; .NOTES<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Adapted from Tyler Siegrist.<br/>
<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Decrypt-AESFileStream -DestionationDirectory 'C:\Users\admin\Desktop\' -DestionationFile 'secrets2.txt' -EncryptedFileName 'secrets.crypto' -EncryptedFilePath 'C:\Users\admin\Desktop\' -AesKey 7f/3e9cQF8yx2UNhG/Dc6XYLKYqXptK1ALB+tP3QUwA= -Verbose<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; Computer &nbsp; &nbsp; Key &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Files<br/>
&nbsp; &nbsp; &nbsp; &nbsp; -------- &nbsp; &nbsp; --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-----<br/>
&nbsp; &nbsp; &nbsp; &nbsp; RYMDEKO-TEST 7f/3e9cQF8yx2UNhG/Dc6XYLKYqXptK1ALB+tP3QUwA= C:\Users\admin\Desktop\secrets2.txt<br/>
<br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $DestionationDirectory,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $DestionationFile,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 2)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFileName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 3)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFilePath,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 4)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AesKey<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; Begin {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ErrorActionPreference = "Stop"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $EncryptedFile = "$EncryptedFilePath$EncryptedFileName"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $FileName = "$DestionationDirectory$DestionationFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [System.Reflection.Assembly]::LoadWithPartialName('System.Security.Cryptography')<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $AESProvider = Create-AesManagedObject -AesKey $AesKey<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # create the file stream for the encryptor<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Try<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader = New-Object System.IO.FileStream($EncryptedFile, [System.IO.FileMode]::Open)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Catch<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] Unable to open file stream object: $EncryptedFile "<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # create destination file<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Try<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter = New-Object System.IO.FileStream($FileName, [System.IO.FileMode]::Create)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Catch<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "[!] Unable to open file to write: $FileStreamWriter"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; #Get IV<br/>
&nbsp; &nbsp; &nbsp; &nbsp; try<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Byte[]]$LenIV = New-Object Byte[] 4<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Read($LenIV, &nbsp;0, 3) | Out-Null<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Int]$LIV = [System.BitConverter]::ToInt32($LenIV, &nbsp;0)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Byte[]]$IV = New-Object Byte[] $LIV<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Seek(4, [System.IO.SeekOrigin]::Begin) | Out-Null<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Read($IV, 0, $LIV) | Out-Null<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $AESProvider.IV = $IV<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write-Verbose "[*] Decrypting $EncryptedFile with an IV of $([System.Convert]::ToBase64String($AESProvider.IV))"<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; catch<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error '[!] Bad IV or File coruption of IV header, check back to backup data returned from encryption.'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # decrypt routine<br/>
&nbsp; &nbsp; &nbsp; &nbsp; try<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Transform = $AESProvider.CreateDecryptor()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Int]$Count = 0<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Int]$BlockSizeBytes = $AESProvider.BlockSize / 8<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Byte[]]$Data = New-Object Byte[] $BlockSizeBytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream = New-Object System.Security.Cryptography.CryptoStream($FileStreamWriter, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Do<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Count = $FileStreamReader.Read($Data, 0, $BlockSizeBytes)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.Write($Data, 0, $Count)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; While ($Count -gt 0)<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.FlushFinalBlock()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Successfully decrypted file: $EncryptedFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; catch<br/>
&nbsp; &nbsp; &nbsp; &nbsp; {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Error "Failed to decrypt $EncryptedFile"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $CryptoStream.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamWriter.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $FileStreamReader.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-Item $FileName -Force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } <br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $len = (Get-Item "$FileName").length<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # TODO: re write the add-type before using this<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # $size = Convert-Size -Size $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $size = $len<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "[*] Final decrypted file size: $size"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result = New-Object –TypeName PSObject<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Computer –Value $env:COMPUTERNAME<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Key –Value $AesKey<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Result | Add-Member –MemberType NoteProperty –Name Files –Value $FileName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
}<br/>
<br/>
</body></html>