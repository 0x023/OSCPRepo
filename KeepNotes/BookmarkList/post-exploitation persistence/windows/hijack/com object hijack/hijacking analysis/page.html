<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Hijacking Analysis</title>
</head><body>During the installation phase, the malware drops two files into the directory: %APPDATA%\Roaming\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}\<br/>
The file names are created using the following scheme: api-ms-win-downlevel-[4char-random]-l1-1-0._dl<br/>
One file is the 32-bit version of the malware and the second one is the 64-bit version.<br/>
<br/>
The second step: the creation of two registry entries:<br/>
<ul><li>HKCU\Software\Classes\CLSID\{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}\InprocServer32</li>
<li>HKCU\Software\Classes\Wow6432Node\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E }\InprocServer32</li>
</ul>
&nbsp;<br/>
For each entry, the default value is the path to the files that were dropped before. In the following screenshot, the file containing rhwm is the 64-bit version of the malware and the file containing dtjb was created for the 32-bit version, respectively. <br/>
<br/>
<img src="image.png" /><br/>
<img src="image 2.png" /><br/>
<br/>
The purpose of the keys is to define a COM object with the CLSIDs {b5f8350b-0548-48b1-a6ee-88bd00b4a5e7} and {BCDE0395-E52F-467C-8E3D-C4579291692E}. If these objects are instanced, the library will be loaded into the respective process. But the CLSIDs are predefined by Microsoft and the newly created owns replace the originals:<br/>
<ul><li>{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}: the CLSID of the class <a href="http://msdn.microsoft.com/en-us/library/accessibility.caccpropservicesclass%28v=vs.110%29.aspx?cs-save-lang=1&cs-lang=cpp#code-snippet-1">CAccPropServicesClass</a>.</li>
<li>{BCDE0395-E52F-467C-8E3D-C4579291692E}: it’s the CLSID of the class <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd316556%28v=vs.85%29.aspx">MMDeviceEnumerator</a>.</li>
</ul>
&nbsp;<br/>
These two instances are used by a lot of applications, for example by the browser (by using the CoCreateInstance() function). With Process Explorer, we are able to list the library loaded into a specific process. Here are the loaded libraries designed for a 32-bit process:<br/>
<img src="image 3.png" /><br/>
<br/>
The following screenshot shows the loaded libraries in a 64-bit process:<br/>
<img src="image 4.png" /><br/>
<br/>
<br/>
In both of these cases, we can see our dropped library. The processes use the registry key previously created to load the malicious library instead of the original Microsoft library<br/>
<br/>
<br/>
Conclusion<br/>
This new approach of persistence mechanism has several advantages: the attacker does not need to perform DLL injection, which is usually monitored by anti-virus software. Therefore, he has overcome one important security measure, in most of the cases.<br/>
As soon as the infection was successful, Microsoft Windows then natively executes the library in the processes of the infected user. Hence, the attacking process is hard to be identified. Using COM hijacking is undoubtedly silent. It is not even detected by Sysinternals’ Autoruns.<br/>
<br/>
So, in our case, we have seen this mechanism being used combined with a RAT and this would mean a hassle for any infected and therefore affected user, as the attackers can spy on him pretty secretly for quite some time. But, obviously, this new persistence mechanism is not limited to the use of RATs. Attackers can combine it with any other type of malware, too!<br/>
<br/>
<br/>
</body></html>