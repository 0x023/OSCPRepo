<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>SCM</title>
</head><body>Service Control Manager<br/>
<br/>
This method is used by psexec and all of its clones to start the executable that psexec creates.<br/>
Result:<br/>
A command to be run on demand and/or boot as SYSTEM (or less privileged accounts, but why would you do that?).<br/>
<br/>
Example:<br/>
step 1/2; a new service can be created:<br/>
sc REMOTECOMPUTERNAME create myservicename binPath= executableToRun start= auto<br/>
alternatively, an existing service can be reconfigured:<br/>
sc REMOTECOMPUTERNAME config existingservice binPath= executableToRun start= auto<br/>
<br/>
step 2/2; executableToRun will run on the remote system on boot as SYSTEM, or when instructed by:<br/>
sc REMOTECOMPUTERNAME start myservicename<br/>
<br/>
variants exist for specifying DLL to load instead of executable, etc.<br/>
<br/>
Implementation details:<br/>
Recent versions of Windows will connect to the RPC portmapper on port 135 then to an RPC server on an ephemeral port (such as 49154 or 49159 etc.). If that fails, or the attacking system has been specially configured, it will fall back to the second method, writing to the svcctl named pipe (a.k.a. srvsvc) on remote computer over SMB. (TCP port 139 or 445 owned by kernel, forwarded to srvsvc pipe)<br/>
srvsvc pipe hosted by Server service in svchost.exe running as SYSTEM.</body></html>